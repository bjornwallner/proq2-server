.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:46 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::AlignIO 3"
.TH Bio::AlignIO 3 "perl v5.6.0" "2001-06-14" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::AlignIO \- Handler for AlignIO Formats
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Bio::AlignIO;
.Ve
.Vb 4
\&    $inputfilename = "testaln.fasta";
\&    $in  = Bio::AlignIO->new(-file => $inputfilename , '-format' => 'fasta');
\&    $out = Bio::AlignIO->new(-file => ">out.aln.pfam" , '-format' => 'pfam');
\&    # note: we quote -format to keep older perl's from complaining.
.Ve
.Vb 3
\&    while ( my $aln = $in->next_aln() ) {
\&        $out->write_aln($aln);
\&    }
.Ve
or
.PP
.Vb 1
\&    use Bio::AlignIO;
.Ve
.Vb 3
\&    $inputfilename = "testaln.fasta";
\&    $in  = Bio::AlignIO->newFh(-file => $inputfilename , '-format' => 'fasta');
\&    $out = Bio::AlignIO->newFh('-format' => 'pfam');
.Ve
.Vb 2
\&    # World's shortest Fasta<->pfam format converter:
\&    print $out $_ while <$in>;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::AlignIO is a handler module for the formats in the AlignIO set
(eg, Bio::AlignIO::fasta). It is the officially sanctioned way of
getting at the alignment objects, which most people should use. The
resulting alignment is a the Bio::SimpleAlign manpage object.
.PP
The idea is that you request a stream object for a particular format.
All the stream objects have a notion of an internal file that is read
from or written to. A particular AlignIO object instance is configured
for either input or output. A specific example of a stream object is
the Bio::AlignIO::fasta object.
.PP
Each stream object has functions
.PP
.Vb 1
\&   $stream->next_aln();
.Ve
and
.PP
.Vb 1
\&   $stream->write_aln($aln);
.Ve
also
.PP
.Vb 1
\&   $stream->type() # returns 'INPUT' or 'OUTPUT'
.Ve
As an added bonus, you can recover a filehandle that is tied to the
AlignIO object, allowing you to use the standard <> and print operations
to read and write sequence objects:
.PP
.Vb 1
\&    use Bio::AlignIO;
.Ve
.Vb 1
\&    $stream = Bio::AlignIO->newFh(-format => 'Fasta'); # read from standard input
.Ve
.Vb 3
\&    while ( $aln = <$stream> ) {
\&        # do something with $aln
\&    }
.Ve
and
.PP
.Vb 1
\&    print $stream $aln; # when stream is in output mode
.Ve
This makes the simplest ever reformatter
.PP
.Vb 1
\&    #!/usr/local/bin/perl
.Ve
.Vb 2
\&    $format1 = shift;
\&    $format2 = shift || die "Usage: reformat format1 format2 < input > output";
.Ve
.Vb 1
\&    use Bio::AlignIO;
.Ve
.Vb 3
\&    $in  = Bio::AlignIO->newFh(-format => $format1 );
\&    $out = Bio::AlignIO->newFh(-format => $format2 );
\&    #note: you might want to quote -format to keep older perl's from complaining.
.Ve
.Vb 1
\&    print $out $_ while <$in>;
.Ve
AlignIO.pm is patterned on the module SeqIO.pm and shares most the
SeqIO.pm features.  One significant difference currently is that
AlignIO.pm usually handles \s-1IO\s0 for only a single alignment at a time (SeqIO.pm
handles \s-1IO\s0 for multiple sequences in a single stream.)  The principal
reason for this is that whereas simultaneously handling multiple
sequences is a common requirement, simultaneous handling of multiple
alignments is not. The only current exception is format \*(L"bl2seq\*(R" which parses
results of the Blast bl2seq program and which may produce several alignment pairs.
This set of alignment pairs can be read using multiple calls to next_aln.
.PP
Capability for \s-1IO\s0 for more than one multiple alignment \- other than for bl2seq
format \-(which may be of use for certain applications such as \s-1IO\s0 for
Pfam libraries) may be included in the future.  For this reason we
keep the name \*(L"\fInext_aln()\fR\*(R" for the alignment input routine, even
though in most cases only one alignment is read (or written) at a time and
the name \*(L"\fIread_aln()\fR\*(R" might be more appropriate.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.Sh "Bio::AlignIO->\fInew()\fR"
.IX Subsection "Bio::AlignIO->new()"
.Vb 3
\&   $seqIO = Bio::AlignIO->new(-file => 'filename',   -format=>$format);
\&   $seqIO = Bio::AlignIO->new(-fh   => \e*FILEHANDLE, -format=>$format);
\&   $seqIO = Bio::AlignIO->new(-format => $format);
.Ve
The \fInew()\fR class method constructs a new Bio::AlignIO object.  The
returned object can be used to retrieve or print BioAlign objects. \fInew()\fR
accepts the following parameters:
.Ip "\-file" 4
.IX Item "-file"
A file path to be opened for reading or writing.  The usual Perl
conventions apply:
.Sp
.Vb 6
\&   'file'       # open file for reading
\&   '>file'      # open file for writing
\&   '>>file'     # open file for appending
\&   '+<file'     # open file read/write
\&   'command |'  # open a pipe from the command
\&   '| command'  # open a pipe to the command
.Ve
.Ip "\-fh" 4
.IX Item "-fh"
You may provide \fInew()\fR with a previously-opened filehandle.  For
example, to read from \s-1STDIN:\s0
.Sp
.Vb 1
\&   $seqIO = Bio::AlignIO->new(-fh => \e*STDIN);
.Ve
Note that you must pass filehandles as references to globs.
.Sp
If neither a filehandle nor a filename is specified, then the module
will read from the \f(CW@ARGV\fR array or \s-1STDIN\s0, using the familiar <>
semantics.
.Ip "\-format" 4
.IX Item "-format"
Specify the format of the file.  Supported formats include:
.Sp
.Vb 8
\&   fasta       FASTA format
\&   pfam        pfam format
\&   selex       selex (hmmer) format
\&   stockholm   stockholm format
\&   prodom      prodom (protein domain) format
\&   clustalw    clustalw (.aln) format
\&   msf         msf (GCG) format
\&   mase        mase (seaview) format
.Ve
Currently only those formats which were implemented in SimpleAlign.pm
have been incorporated in AlignIO.pm.  Specifically, mase, stockholm
and prodom have only been implemented for input. Clustalw format has only
been implemented for output.
.Sp
If no format is specified and a filename is given, then the module
will attempt to deduce it from the filename.  If this is unsuccessful,
Fasta format is assumed.
.Sp
The format name is case insensitive.  '\s-1FASTA\s0', 'Fasta' and 'fasta' are
all supported.
.Sh "Bio::AlignIO->\fInewFh()\fR"
.IX Subsection "Bio::AlignIO->newFh()"
.Vb 3
\&   $fh = Bio::AlignIO->newFh(-fh   => \e*FILEHANDLE, -format=>$format);
\&   $fh = Bio::AlignIO->newFh(-format => $format);
\&   # etc.
.Ve
This constructor behaves like \fInew()\fR, but returns a tied filehandle
rather than a Bio::AlignIO object.  You can read sequences from this
object using the familiar <> operator, and write to it using \fIprint()\fR.
The usual array and \f(CW$_\fR semantics work.  For example, you can read all
sequence objects into an array like this:
.PP
.Vb 1
\&  @sequences = <$fh>;
.Ve
Other operations, such as \fIread()\fR, \fIsysread()\fR, \fIwrite()\fR, \fIclose()\fR, and \fIprintf()\fR 
are not supported.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
See below for more detailed summaries.  The main methods are:
.Sh "$alignment = \f(CW$AlignIO\fR->\fInext_aln()\fR"
.IX Subsection "$alignment = $AlignIO->next_aln()"
Fetch an alignment from a formatted file.
.Sh "$AlignIO->write_aln($aln)"
.IX Subsection "$AlignIO->write_aln($aln)"
Write the specified alignment to a file..
.Sh "\fITIEHANDLE()\fR, \fIREADLINE()\fR, \fIPRINT()\fR"
.IX Subsection "TIEHANDLE(), READLINE(), PRINT()"
These provide the tie interface.  See the perltie manpage for more details.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org               - General discussion
\&  http://bio.perl.org/MailList.html   - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
 the bugs and their resolution.
 Bug reports can be submitted via email or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \- Peter Schattner"
.IX Header "AUTHOR - Peter Schattner"
Email: schattner@alum.mit.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 7
\& Title   : new
\& Usage   : $stream = Bio::AlignIO->new(-file => $filename, -format => 'Format')
\& Function: Returns a new seqstream
\& Returns : A Bio::AlignIO::Handler initialised with the appropriate format
\& Args    : -file => $filename 
\&           -format => format
\&           -fh => filehandle to attach to
.Ve
.Sh "newFh"
.IX Subsection "newFh"
.Vb 8
\& Title   : newFh
\& Usage   : $fh = Bio::AlignIO->newFh(-file=>$filename,-format=>'Format')
\& Function: does a new() followed by an fh()
\& Example : $fh = Bio::AlignIO->newFh(-file=>$filename,-format=>'Format')
\&           $sequence = <$fh>;   # read a sequence object
\&           print $fh $sequence; # write a sequence object
\& Returns : filehandle tied to the Bio::AlignIO::Fh class
\& Args    :
.Ve
.Sh "fh"
.IX Subsection "fh"
.Vb 8
\& Title   : fh
\& Usage   : $obj->fh
\& Function:
\& Example : $fh = $obj->fh;      # make a tied filehandle
\&           $sequence = <$fh>;   # read a sequence object
\&           print $fh $sequence; # write a sequence object
\& Returns : filehandle tied to the Bio::AlignIO::Fh class
\& Args    :
.Ve
.Sh "_load_format_module"
.IX Subsection "_load_format_module"
.Vb 6
\& Title   : _load_format_module
\& Usage   : *INTERNAL AlignIO stuff*
\& Function: Loads up (like use) a module at run time on demand
\& Example :
\& Returns : 
\& Args    :
.Ve
.Sh "next_aln"
.IX Subsection "next_aln"
.Vb 5
\& Title   : next_aln
\& Usage   : $aln = stream->next_aln
\& Function: reads the next $aln object from the stream
\& Returns : a Bio::Seq sequence object
\& Args    :
.Ve
.Sh "write_aln"
.IX Subsection "write_aln"
.Vb 5
\& Title   : write_aln
\& Usage   : $stream->write_aln($aln)
\& Function: writes the $aln object into the stream
\& Returns : 1 for success and 0 for error
\& Args    : Bio::Seq object
.Ve
.Sh "close"
.IX Subsection "close"
.Vb 6
\& Title   : close
\& Usage   : $seqio->close()
\& Function: Closes the file handle associated with this seqio system
\& Example :
\& Returns : 
\& Args    :
.Ve
.Sh "_print"
.IX Subsection "_print"
.Vb 5
\& Title   : _print
\& Usage   : $obj->_print(@lines)
\& Function: 
\& Example : 
\& Returns : writes output
.Ve
.Sh "_readline"
.IX Subsection "_readline"
.Vb 5
\& Title   : _readline
\& Usage   : $obj->_readline($newval)
\& Function: 
\& Example : 
\& Returns : reads a line of input
.Ve
.Sh "_filehandle"
.IX Subsection "_filehandle"
.Vb 6
\& Title   : _filehandle
\& Usage   : $obj->_filehandle($newval)
\& Function: 
\& Example : 
\& Returns : value of _filehandle
\& Args    : newvalue (optional)
.Ve
.Sh "_guess_format"
.IX Subsection "_guess_format"
.Vb 6
\& Title   : _guess_format
\& Usage   : $obj->_guess_format($filename)
\& Function: 
\& Example : 
\& Returns : guessed format of filename (lower case)
\& Args    :
.Ve
