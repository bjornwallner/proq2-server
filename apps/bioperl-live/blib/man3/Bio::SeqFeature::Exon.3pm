.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:00 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::SeqFeature::Exon 3"
.TH Bio::SeqFeature::Exon 3 "perl v5.6.0" "2001-06-20" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::SeqFeature::Exon
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Bio::SeqFeature::Exon;
\&  my $Exon = Bio::SeqFeature::Exon->new( # takes same args as SeqFeature::Generic
\&      -start => 10,
\&      -end => 100,
\&      -frame => '.',
\&      -primary => 'high_GC_exon',
\&      -strand => '1',
\&      -source => 'cDNA_alignment',
\&      -score => '100',
\&      type => 'internal');   # Descr. of the Exon type; *not* Cont.Vocab.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Creates Intron type sequence features.  These are essentially SeaFeature::Generic
features, but report themselves as \*(L"Bio::SeqFeature::Intron\*(R" when you query them
with a \f(CW$Feature\fR->isa.
.SH "AUTHORS \- Hilmar Lapp, Mark Wilkinson"
.IX Header "AUTHORS - Hilmar Lapp, Mark Wilkinson"
Based on original code and concept from Hilmar Lapp (hlapp@gmx.net)
.PP
Mark Wilkinson (mwilkinson@gene.pbi.nrc.ca)
Plant Biotechnology Institute, National Research Council of Canada.
Copyright (c) National Research Council of Canada, April, 2001.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
Anyone who intends to use and uses this software and code acknowledges and
agrees to the following: The National Research Council of Canada (herein \*(L"\s-1NRC\s0\*(R")
disclaims any warranties, expressed, implied, or statutory, of any kind or
nature with respect to the software, including without limitation any warranty
or merchantability or fitness for a particular purpose.  \s-1NRC\s0 shall not be liable
in any event for any damages, whether direct or indirect,
consequential or incidental, arising from the use of the software.
.SH "CONTACT"
.IX Header "CONTACT"
Mark Wilkinson (mwilkinson@gene.pbi.nrc.ca)
.SH "METHODS"
.IX Header "METHODS"
identical to SeqFeature::Generic except for:
.Sh "type"
.IX Subsection "type"
.Vb 3
\&  Usage:  $Exon->type($type);
\&  Args:   optional string indicating new type
\&  Returns: current or newly set type
.Ve
.Sh "type"
.IX Subsection "type"
.Vb 4
\& Title   : type
\& Usage   : $tag = $exon->type()
\&           $exon->type('internal')
\& Function: Get/set the type for the exon feature.
.Ve
.Vb 1
\&           Conrolled Vocab. based on $exon->valid_types
.Ve
.Vb 2
\& Returns : A string.
\& Args    : A string on set.
.Ve
.Sh "location"
.IX Subsection "location"
.Vb 4
\& Title   : location
\& Usage   : my $location = $exon->location()
\& Function: Returns a location object suitable for identifying the location
\&           of the exon on the sequence or parent feature.
.Ve
.Vb 2
\&           This method is overridden here to restrict allowed location types
\&           to non-compound locations.
.Ve
.Vb 2
\& Returns : Bio::LocationI object
\& Args    : none
.Ve
.Sh "is_coding"
.IX Subsection "is_coding"
.Vb 11
\& Title   : is_coding
\& Usage   : if($exon->is_coding()) {
\&                   # do something
\&           }
\&           if($is_utr) {
\&               $exon->is_coding(0);
\&           }
\& Function: Get/set whether or not the exon codes for amino acid.
\& Returns : TRUE if the object represents a feature translated into protein,
\&           and FALSE otherwise.
\& Args    : A boolean value on set.
.Ve
.Sh "cds"
.IX Subsection "cds"
.Vb 3
\& Title   : cds()
\& Usage   : $cds = $exon->cds();
\& Function: Get the coding sequence of the exon as a sequence object.
.Ve
.Vb 3
\&           The sequence of the returned object is prefixed by Ns (lower case)
\&           if the frame of the exon is defined and different from zero. The
\&           result is that the first base starts a codon (frame 0).
.Ve
.Vb 4
\&           This implementation returns undef if the particular exon is
\&           not translated to protein, i.e., is_coding() returns FALSE. Undef
\&           will also be returned if no sequence is attached to this exon
\&           feature.
.Ve
.Vb 2
\& Returns : A Bio::PrimarySeqI implementing object.
\& Args    :
.Ve
