.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:21 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::Root::RootI 3"
.TH Bio::Root::RootI 3 "perl v5.6.0" "2001-06-18" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::Root::RootI \- Abstract interface to root object code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # any bioperl or bioperl compliant object is a RootI 
\&  # compliant object
.Ve
.Vb 1
\&  $obj->throw("This is an exception");
.Ve
.Vb 3
\&  eval {
\&      $obj->throw("This is catching an exception");
\&  };
.Ve
.Vb 5
\&  if( $@ ) {
\&      print "Caught exception";
\&  } else {
\&      print "no exception";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is just a set of methods which do not assumme \fBanything\fR about the object
they are on. The methods provide the ability to throw exceptions with nice
stack traces.
.PP
This is what should be inherieted by all bioperl compliant interfaces, even
if they are exotic XS/CORBA/Other perl systems.
.SH "CONTACT"
.IX Header "CONTACT"
Functions originally from Steve Chervitz. Refactored by Ewan Birney.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 2
\& Purpose   : generic intantiation function can be overridden if 
\&             special needs of a module cannot be done in _initialize
.Ve
.Sh "throw"
.IX Subsection "throw"
.Vb 6
\& Title   : throw
\& Usage   : $obj->throw("throwing exception message")
\& Function: Throws an exception, which, if not caught with an eval brace
\&           will provide a nice stack trace to STDERR with the message
\& Returns : nothing
\& Args    : A string giving a descriptive error message
.Ve
.Sh "warn"
.IX Subsection "warn"
.Vb 11
\& Title   : warn
\& Usage   : $object->warn("Warning message");
\& Function: Places a warning. What happens now is down to the
\&           verbosity of the object  (value of $obj->verbose) 
\&            verbosity 0 or not set => small warning
\&            verbosity -1 => no warning
\&            verbosity 1 => warning with stack trace
\&            verbosity 2 => converts warnings into throw
\& Example :
\& Returns : 
\& Args    :
.Ve
.Sh "verbose"
.IX Subsection "verbose"
.Vb 9
\& Title   : verbose
\& Usage   : $self->verbose(1)
\& Function: Sets verbose level for how ->warn behaves
\&           -1 = no warning
\&            0 = standard, small warning
\&            1 = warning with stack trace
\&            2 = warning becomes throw
\& Returns : nothing
\& Args    : -1,0,1 or 2
.Ve
.Sh "stack_trace_dump"
.IX Subsection "stack_trace_dump"
.Vb 6
\& Title   : stack_trace_dump
\& Usage   :
\& Function:
\& Example :
\& Returns : 
\& Args    :
.Ve
.Sh "stack_trace"
.IX Subsection "stack_trace"
.Vb 6
\& Title   : stack_trace
\& Usage   : @stack_array_ref= $self->stack_trace
\& Function: gives an array to a reference of arrays with stack trace info
\&           each coming from the caller(stack_number) call
\& Returns : array containing a reference of arrays
\& Args    : none
.Ve
.Sh "_rearrange"
.IX Subsection "_rearrange"
.Vb 50
\& Usage     : $object->_rearrange( array_ref, list_of_arguments)
\& Purpose   : Rearranges named parameters to requested order.
\& Example   : $self->_rearrange([qw(SEQUENCE ID DESC)],@param);
\&           : Where @param = (-sequence => $s, 
\&           :                 -id       => $i, 
\&           :                 -desc     => $d);
\& Returns   : @params - an array of parameters in the requested order.
\&           : The above example would return ($s, $i, $d)
\& Argument  : $order : a reference to an array which describes the desired
\&           :          order of the named parameters.
\&           : @param : an array of parameters, either as a list (in
\&           :          which case the function simply returns the list),
\&           :          or as an associative array with hyphenated tags
\&           :          (in which case the function sorts the values 
\&           :          according to @{$order} and returns that new array.)
\&           :          The tags can be upper, lower, or mixed case
\&           :          but they must start with a hyphen (at least the
\&           :          first one should be hyphenated.)
\& Source    : This function was taken from CGI.pm, written by Dr. Lincoln
\&           : Stein, and adapted for use in Bio::Seq by Richard Resnick and
\&           : then adapted for use in Bio::Root::Object.pm by Steve A. Chervitz.
\& Comments  : (SAC)
\&           : This method may not be appropriate for method calls that are
\&           : within in an inner loop if efficiency is a concern.
\&           :
\&           : Parameters can be specified using any of these formats:
\&           :  @param = (-name=>'me', -color=>'blue');
\&           :  @param = (-NAME=>'me', -COLOR=>'blue');
\&           :  @param = (-Name=>'me', -Color=>'blue');
\&           :  @param = ('me', 'blue');  
\&           : A leading hyphenated argument is used by this function to 
\&           : indicate that named parameters are being used.
\&           : Therefore, the ('me', 'blue') list will be returned as-is.
\&           :
\&           : Note that Perl will confuse unquoted, hyphenated tags as 
\&           : function calls if there is a function of the same name 
\&           : in the current namespace:
\&           :    -name => 'foo' is interpreted as -&name => 'foo'
\&           :
\&           : For ultimate safety, put single quotes around the tag:
\&           :    ('-name'=>'me', '-color' =>'blue');
\&           : This can be a bit cumbersome and I find not as readable
\&           : as using all uppercase, which is also fairly safe:
\&           :    (-NAME=>'me', -COLOR =>'blue');
\&           :
\&           : Personal note (SAC): I have found all uppercase tags to
\&           : be more managable: it involves less single-quoting,
\&           : the code is more readable, and there are no method naming conlicts.
\&           : Regardless of the style, it greatly helps to line
\&           : the parameters up vertically for long/complex lists.
.Ve
See Also   : the _initialize manpage() 
.Sh "_register_for_cleanup"
.IX Subsection "_register_for_cleanup"
.Vb 7
\& Title   : _register_for_cleanup
\& Usage   : -- internal --
\& Function: Register a method to be called at DESTROY time. This is useful
\&           and sometimes essential in the case of multiple inheritance for
\&           classes coming second in the sequence of inheritance.
\& Returns : 
\& Args    : a reference to a method
.Ve
