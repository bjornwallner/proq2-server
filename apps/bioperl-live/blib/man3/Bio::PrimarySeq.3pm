.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:09 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::PrimarySeq 3"
.TH Bio::PrimarySeq 3 "perl v5.6.0" "2001-06-12" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::PrimarySeq \- Bioperl lightweight Sequence Object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # The Bio::SeqIO for file reading, Bio::DB::GenBank for
\&  # database reading
\&  use Bio::Seq;
\&  use Bio::SeqIO;
\&  use Bio::DB::GenBank;
.Ve
.Vb 6
\&  #make from memory
\&  $seqobj = Bio::PrimarySeq->new ( -seq => 'ATGGGGTGGGCGGTGGGTGGTTTG',
\&                            -id  => 'GeneFragment-12',
\&                            -accession_number => 'X78121',
\&                            -moltype => 'dna'
\&                            );
.Ve
.Vb 3
\&  # read from file
\&  $inputstream = Bio::SeqIO->new(-file => "myseq.fa",-format => 'Fasta');
\&  $seqobj = $inputstream->next_seq();
.Ve
.Vb 3
\&  # get from database
\&  $db = Bio::DB::GenBank->new();
\&  $seqobj = $db->get_Seq_by_acc('X78121');
.Ve
.Vb 1
\&  # to get out parts of the sequence.
.Ve
.Vb 1
\&  print "Sequence ", $seqobj->id(), " with accession ", $seqobj->accession, " and desc ", $seqobj->desc, "\en";
.Ve
.Vb 2
\&  $string  = $seqobj->seq();
\&  $string2 = $seqobj->subseq(1,40);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PrimarySeq is a lightweight Sequence object, storing little more than
the sequence, its name, a computer useful unique name. It does not
contain sequence features or other information.  To have a sequence
with sequence features you should use the Seq object which uses this
object.
.PP
Sequence objects are defined by the Bio::PrimarySeqI interface, and this
object is a pure Perl implementation of the interface (if that's
gibberish to you, don't worry. The take home message is that this
object is the bioperl default sequence object, but other people can
use their own objects as sequences if they so wish). If you are
interested in wrapping your own objects as compliant Bioperl sequence
objects, then you should read the Bio::PrimarySeqI documentation
.PP
The documenation of this object is a merge of the Bio::PrimarySeq and
Bio::PrimarySeqI documentation.  This allows all the methods which you can
call on sequence objects here.
.SH "Reimplementation"
.IX Header "Reimplementation"
The Sequence object was completely rewritten for the 0.6 series. This
was because the old Sequence object was becoming heavily bloated and
difficult to maintain. There are some key changes from the old object
to the new object, but basically, everything should work with the new
object with a minimal number of changes.
.PP
The key change is that the format \s-1IO\s0 has been removed from this object
and moved to the Bio::SeqIO system, which provides a much better way
to encapsulate the sequence format reading. Please read the SeqIO
documentation, but the take home message is that lines like
.PP
.Vb 2
\&    # old style reading from files
\&    $seq = Bio::Seq->new( -file => "myfile");
.Ve
Becomes
.PP
.Vb 3
\&    # new style reading from files.
\&    $inputstream = Bio::SeqIO->new( -file => "myfile", -format => 'Fasta');
\&    $seqobj = $inputstream->next_seq();
.Ve
For writing files, a similar system is used
.PP
.Vb 2
\&     # old style writing to files
\&     print OUTPUT $seq->layout_fasta;
.Ve
.Vb 3
\&     # new style writing to files
\&     $outputstream = Bio::SeqIO->new( -fh => \e*OUTPUT, -format => 'Fasta');
\&     $outputstream->write_seq($seqobj);
.Ve
.Sh "Deprecated methods"
.IX Subsection "Deprecated methods"
A number of methods which were present in the old 0.04/0.05 series
have been deprecated.  Most of these methods work as before, but
provide a warning that someone has called a deprecated method.
.Ip "getseq \- use seq/subseq instead" 4
.IX Item "getseq - use seq/subseq instead"
.Ip "str \- use seq/subseq instead" 4
.IX Item "str - use seq/subseq instead"
.Ip "ary \- use seq/subseq with your own split afterwards" 4
.IX Item "ary - use seq/subseq with your own split afterwards"
.Ip "type \- use moltype, but notice that moltype returns different values (lowercase)" 4
.IX Item "type - use moltype, but notice that moltype returns different values (lowercase)"
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org             - General discussion
\&  http://bio.perl.org/MailList.html - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@sanger.ac.uk
.PP
Describe contact details here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $seq    = Bio::PrimarySeq->new( -seq => 'ATGGGGGTGGTGGTACCCT',
\&                                           -id  => 'human_id',
\&                                           -accession_number => 'AL000012',
\&                                           );
.Ve
.Vb 3
\& Function: Returns a new primary seq object from
\&           basic constructors, being a string for the sequence
\&           and strings for id and accession_number.
.Ve
.Vb 5
\&           Note that you can provide an empty sequence string. However, in
\&           this case you MUST specify the type of sequence you wish to
\&           initialize by the parameter -moltype. See moltype() for possible
\&           values.
\& Returns : a new Bio::PrimarySeq object
.Ve
.Sh "seq"
.IX Subsection "seq"
.Vb 7
\& Title   : seq
\& Usage   : $string    = $obj->seq()
\& Function: Returns the sequence as a string of letters. The
\&           case of the letters is left up to the implementer.
\&           Suggested cases are upper case for proteins and lower case for
\&           DNA sequence (IUPAC standard), but you should not rely on this
\& Returns : A scalar
.Ve
.Sh "validate_seq"
.IX Subsection "validate_seq"
.Vb 8
\& Title   : validate_seq
\& Usage   : if(! $seq->validate_seq($seq_str) ) {
\&                print "sequence $seq_str is not valid for an object of type ",
\&                      ref($seq), "\en";
\&           }
\& Function: Validates a given sequence string. A validating sequence string
\&           must be accepted by seq(). A string that does not validate will
\&           lead to an exception if passed to seq().
.Ve
.Vb 2
\&           The implementation provided here does not take moltype() into
\&           account. Allowed are all letters (A-Z) and '-','.', '*' and '?'.
.Ve
.Vb 4
\& Example :
\& Returns : TRUE if the supplied sequence string is valid for the object, and
\&           FALSE otherwise.
\& Args    : The sequence string to be validated.
.Ve
.Sh "subseq"
.IX Subsection "subseq"
.Vb 8
\& Title   : subseq
\& Usage   : $substring = $obj->subseq(10,40);
\& Function: returns the subseq from start to end, where the first base
\&           is 1 and the number is inclusive, ie 1-2 are the first two
\&           bases of the sequence
\& Returns : a string
\& Args    : integer for start position
\&           integer for end position
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 6
\& Title   : length
\& Usage   : $len = $seq->length()
\& Function:
\& Example :
\& Returns : integer representing the length of the sequence.
\& Args    :
.Ve
.Sh "display_id"
.IX Subsection "display_id"
.Vb 3
\& Title   : display_id
\& Usage   : $id_string = $obj->display_id();
\& Function: returns the display id, aka the common name of the Sequence object.
.Ve
.Vb 8
\&         The semantics of this is that it is the most likely string to be
\&         used as an identifier of the sequence, and likely to have "human" readability.
\&         The id is equivalent to the ID field of the GenBank/EMBL databanks and
\&         the id field of the Swissprot/sptrembl database. In fasta format, the >(\eS+)
\&         is presumed to be the id, though some people overload the id to embed other
\&         information. Bioperl does not use any embedded information in the ID field,
\&         and people are encouraged to use other mechanisms (accession field for example,
\&         or extending the sequence object) to solve this.
.Ve
.Vb 2
\& Returns : A string
\& Args    : None
.Ve
.Sh "accession_number"
.IX Subsection "accession_number"
.Vb 8
\& Title   : accession_number
\& Usage   : $unique_key = $obj->accession_number;
\& Function: Returns the unique biological id for a sequence, commonly
\&           called the accession_number. For sequences from established
\&           databases, the implementors should try to use the correct
\&           accession number. Notice that primary_id() provides the
\&           unique id for the implemetation, allowing multiple objects
\&           to have the same accession number in a particular implementation.
.Ve
.Vb 4
\&           For sequences with no accession number, this method should return
\&           "unknown".
\& Returns : A string
\& Args    : A string (optional) for setting
.Ve
.Sh "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $unique_key = $obj->primary_id;
\& Function: Returns the unique id for this object in this
\&           implementation. This allows implementations to manage
\&           their own object ids in a way the implementaiton can control
\&           clients can expect one id to map to one object.
.Ve
.Vb 4
\&           For sequences with no natural primary id, this method should return
\&           a stringified memory location.
\& Returns : A string
\& Args    : A string (optional, for setting)
.Ve
.Sh "moltype"
.IX Subsection "moltype"
.Vb 4
\& Title   : moltype
\& Usage   : if( $obj->moltype eq 'dna' ) { /Do Something/ }
\& Function: Returns the type of sequence being one of
\&           'dna', 'rna' or 'protein'. This is case sensitive.
.Ve
.Vb 2
\&           This is not called <type> because this would cause
\&           upgrade problems from the 0.5 and earlier Seq objects.
.Ve
.Vb 4
\& Returns : a string either 'dna','rna','protein'. NB - the object must
\&           make a call of the type - if there is no type specified it
\&           has to guess.
\& Args    : none
.Ve
.Sh "desc"
.IX Subsection "desc"
.Vb 6
\& Title   : desc
\& Usage   : $obj->desc($newval)
\& Function: Get/set description of the sequence.
\& Example :
\& Returns : value of desc
\& Args    : newvalue (optional)
.Ve
.Sh "can_call_new"
.IX Subsection "can_call_new"
.Vb 6
\& Title   : can_call_new
\& Usage   :
\& Function:
\& Example :
\& Returns :
\& Args    :
.Ve
.Sh "id"
.IX Subsection "id"
.Vb 6
\& Title   : id
\& Usage   : $id = $seq->id()
\& Function: This is mapped on display_id
\& Example :
\& Returns :
\& Args    :
.Ve
.SH "Methods Inherieted from Bio::PrimarySeqI"
.IX Header "Methods Inherieted from Bio::PrimarySeqI"
These methods are available on Bio::PrimarySeq, although they are actually
implemented on Bio::PrimarySeqI
.Sh "revcom"
.IX Subsection "revcom"
.Vb 6
\& Title   : revcom
\& Usage   : $rev = $seq->revcom()
\& Function: Produces a new Bio::SeqI implementing object which
\&           is the reversed complement of the sequence. For protein
\&           sequences this throws an exception of
\&           "Sequence is a protein. Cannot revcom"
.Ve
.Vb 4
\&           The id is the same id as the orginal sequence, and the
\&           accession number is also indentical. If someone wants to
\&           track that this sequence has be reversed, it needs to
\&           define its own extensions
.Ve
.Vb 1
\&           To do an inplace edit of an object you can go:
.Ve
.Vb 1
\&           $seqobj = $seqobj->revcom();
.Ve
.Vb 3
\&           This of course, causes Perl to handle the garbage
\&           collection of the old object, but it is roughly speaking as
\&           efficient as an inplace edit.
.Ve
.Vb 2
\& Returns : A new (fresh) Bio::SeqI object
\& Args    : none
.Ve
.Sh "trunc"
.IX Subsection "trunc"
.Vb 3
\& Title   : trunc
\& Usage   : $subseq = $myseq->trunc(10,100);
\& Function: Provides a truncation of a sequence,
.Ve
.Vb 3
\& Example :
\& Returns : a fresh Bio::SeqI implementing object
\& Args    :
.Ve
.SH "Internal methods"
.IX Header "Internal methods"
These are internal methods to PrimarySeq
.Sh "_guess_type"
.IX Subsection "_guess_type"
.Vb 6
\& Title   : _guess_type
\& Usage   :
\& Function:
\& Example :
\& Returns :
\& Args    :
.Ve
