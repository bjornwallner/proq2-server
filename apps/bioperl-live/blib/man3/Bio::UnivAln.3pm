.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:38 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::UnivAln 3"
.TH Bio::UnivAln 3 "perl v5.6.0" "2001-05-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::UnivAln \- Bioperl alignment object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This Perl module is intended to simplify the handling of biosequence alignments.
When in doubt, always check our Homepage for the newest version, contact emails,
help files, etc: http://www.techfak.uni-bielefeld.de/bcd/Perl/Bio/welcome.html
.PP
See the the REVISION HISTORY entry elsewhere in this document for recent bugfixes and enhancements.
.Sh "Object Creation in a Nutshell"
.IX Subsection "Object Creation in a Nutshell"
.Vb 1
\&  use Bio::UnivAln;
.Ve
.Vb 14
\&  my $aln = Bio::UnivAln->new('t/alnfile.fasta');
\&  $aln = Bio::UnivAln->new(-file=>'t/alnfile.aa',
\&                       -desc=>'Sample alignment',
\&                       -type=>'amino',
\&                       -ffmt=>'raw'      # 1 line in file -> 1 sequence
\&                      );
\&  $aln = Bio::UnivAln->new(-seqs=>"TCCCGCGTCAACTG\enTGGTGCTTCAACCG\enACTTG--TCAACTG");
\&  $aln = Bio::UnivAln->new(-seqs=>[$sequence_strg,\e@character_list,$bioSeqObject]);
\&  $aln = Bio::UnivAln->new(-seqs=> ['ACCCGCGTCAACTG',
\&           ['A','G','G','G','G','C','T','T','C','A','A','C','C','G'],
\&           Bio::Seq->new(-seq=>'ACTTG--TCAACTG')
\&         ]);
\&  $aln = Bio::UnivAln->new($file,$seqs,$id,$desc,$names,$row_ids,$col_ids,
\&           $row_descs,$col_descs,$numbering,$type,$ffmt,$descffmt,$inplace);
.Ve
.Sh "Object Manipulation in a Nutshell"
.IX Subsection "Object Manipulation in a Nutshell"
.Vb 1
\&  OUTPUT
.Ve
.Vb 5
\&  $aln->ffmt('fasta');   # set default output format
\&  print "\en aln in default format:\en", $aln->layout();
\&  print "\en aln in raw format:\en", $aln->layout("raw");
\&  print "\en aln in fasta format:\en", $aln->layout("fasta"), "\en";
\&  print "\en aln in MSF format (via readseq):\en", $aln->layout("MSF"), "\en";
.Ve
.Vb 1
\&  SLICING
.Ve
.Vb 6
\&  my $alnSlice = $aln->seqs(1,3,1,2); # multiline string of rows 1-3, columns 1-2
\&      print $alnSlice, "\en";
\&  my @alnSlice = $aln->seqs([1..3], [1,4]); # multidimensional array
\&                                            # of rows 1-3, columns 1+4
\&      for $aref ( @alnSlice ) { print @$aref, "\en"; }
\&  $alnSlice = $aln->seqs([3,2,3,1], [1,3..5]); # rows 3,2,3,1, cols 1,3..5
.Ve
.Vb 1
\&  ADVANCED SLICING
.Ve
.Vb 9
\&      sub has_purine {
\&        my $str = join "", @{ $_[0] };
\&        if ($str =~ /[AaGgRr]+/) {return 1;} else {return 0;}
\&      }
\&  @alnSlice = $aln->seqs([1,2,3], \e&has_purine); # rows 1-3, and from these
\&      # only the entries of columns for which has_purine returns 1
\&  $alnSlice = $aln->seqs({ids=>'SeqA SeqB'},{ids=>'ColA ColB ColC'});
\&  $aln->inplace(1); $aln->seqs({ids=>'A B'},[1..6]); $aln->inplace(0);
\&      # manipulates the object itself, assigning the slice internally
.Ve
.Vb 1
\&  MAPPING
.Ve
.Vb 2
\&  @resSlice = $aln->map_r(\e&has_purine, [1..3]); # 1,0,1 if row 1+3 has purine
\&  @resSlice = $aln->map_c(\e&has_purine, [1,4]); # 1,0 if column 1 has purine
.Ve
.Vb 1
\&  UTILITIES
.Ve
.Vb 14
\&  $resSlice = $aln->consensus(); # 75% majority needed for consensus letter
\&  $resSlice = $aln->consensus(0.6, [1,3]); # 60% majority, columns 1+3 only
\&  $resSlice = $aln->var_sites(); # no columns that are invariable ...
\&  $indices = $aln->var_inds();   # ... and their indices
\&  $resSlice = $aln->invar_sites(); # only columns that are invariable
\&  $indices = $aln->invar_inds();   # (..inds() is available for most utilities)
\&  $resSlice = $aln->var_sites(0.6); # no columns with >= 60% maj. of 1 letter
\&  $resSlice = $aln->invar_sites(0.6); # only columns with >= 60% majority
\&  $resSlice = $aln->gap_free_sites();
\&  $resSlice = $aln->no_allgap_sites(); # exclude sites that only have gaps
\&  $resSlice = $aln->reverse([1,3]); # reverse of rows 1+3 only
\&  $resSlice = $aln->complement([1,3]); # dna/rna complement of rows 1+3 only
\&  $resSlice = $aln->revcom([1,3]); # reverse complement, rows 1+3 only
\&  $resSlice = $aln->remove_gaps(); # original sequences without gaps
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
This module is included with the central Bioperl distribution:
.PP
.Vb 2
\&   http://bio.perl.org/Core/Latest
\&   ftp://bio.perl.org/pub/DIST
.Ve
Follow the installation instructions included in the \s-1README\s0 file.
.PP
The following are the installation instructions from the original UnivAlign
distribution for installing UnivAlign.pm by itself. These are not necessary if
installing from the central Bioperl distribution. Note that the central
distribution does not currently run the more extensive univaln.t2
test harness.
.PP
The original installation package is available from:
.PP
.Vb 1
\& http://www.techfak.uni-bielefeld.de/bcd/Perl/Bio/#univaln
.Ve
To install, untar it and run the following commands in the module directory
created by tar:
.PP
.Vb 4
\&        % perl Makefile.PL
\&        % make
\&        % make test
\&        % make install
.Ve
For intensive testing, see t/univaln.t2. Run that script via
.PP
.Vb 1
\&        % perl t/univaln.t2 > t/my_univaln
.Ve
and compare the output with the file t/univaln.o .
Expected error messages can be found in t/univaln2_expected_errors .
.PP
If you do not have superuser installation privileges, or to install
in a different directory, you can do one of two things:
.PP
1) Either copy the UnivAln.pm module into the ``Bio'' subdirectory of
an accessible Perl module directory (e.g. /my/perl/lib/Bio/).
(One possible ``accessible Perl module directory'' is your current working
directory; there you can create a subdirectory named ``Bio'' and place
UnivAln.pm in that subdirectory. Then, you can start scripts using
Bio::UnivAln from your current working directory.)
.PP
2) Or, run the above commands but specify an alternate location for
the module by supplying a \s-1PREFIX\s0 argument to the first command:
.PP
.Vb 1
\&        % perl Makefile.PL PREFIX=/my/perl/stuff
.Ve
This will place the module into '/my/perl/stuff/lib/site_lib/'. To
specify a directory for the module file, set the \f(CW$INSTALLSITELIB\fR
variable in Makefile.PL (e.g., \f(CW$INSTALLSITELIB\fR = '/my/perl/lib');
.PP
The make install command may report problems with creating documentation
files (pod2man/perllocal.pod); please find the documentation in
UnivAln.pm.html instead.
.PP
If you have Bio::Seq installed and want to test Bio::Seq usage by
Bio::UnivAln, you need enable the line
``use Bio::Seq;'' at the beginning of t/univaln.t2;
Bio::Seq can be found via http://www.techfak.uni-bielefeld.de/bcd/Perl/Bio/ .
Note that the test script will also test error handling; you can expect the
error messages included in the file univaln.t2_expected_errors \*(-- these are \s-1OK\s0.
.PP
If you wish that the module uses Don Gilbert's readseq package for sequence
format conversion (Version 1 Feb 1993), you can set the environment variable
`\s-1READSEQ_DIR\s0'" appropriately. (Currently, only ``fasta'' and ``raw'' format
are supported directly by UnivAln.pm.)
Then, the program detects and uses `readseq' automatically, if it is in the
specified directory (the default directory is ``./''). Modifying the
environment variable `\s-1READSEQ\s0' changes the expected name of the executable.
For example, \f(CW$ENV\fR{\s-1READSEQ_DIR\s0} may be ``/vol/biotools/bin/'' and \f(CW$ENV\fR{\s-1READSEQ\s0}
``readseq2.0''. Readseq will give you support for \s-1PIR/CODATA\s0, \s-1MSF/GCG\s0 and
\&\s-1PAUP/NEXUS\s0 formats; \s-1ASN\s0.1 does not seem to work reliably.
(URLs: http://iubio.bio.indiana.edu/IUBio-Software+Data/molbio/readseq/
http://dot.imgen.bcm.tmc.edu:9331/seq-util/Help/readseq.html
http://bimas.dcrt.nih.gov/molbio/readseq/formats.html )
.PP
Similar support for conversion from Clustal format, using Clustal as
a converter, is implemented, but not properly tested and documented.
The relevant environment variables are `\s-1CLUSTAL_DIR\s0' and `\s-1CLUSTAL\s0'.
(\s-1URL:\s0 http://www-igbmc.u-strasbg.fr/BioInfo/ClustalW/Top.html )
.PP
(Thanks to Steve A. Chervitz for his help with bundling the module !)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is the Bio::UnivAln alignment object which is part of
the Bioperl project. Currently it has some nice methods for accessing
an alignment after reading it in from certain formats, incl. utilities
like consensus and reverse complement. Bio::Seq (single sequences)
is only needed if you explicitly want to use these.
.PP
(Most examples below are taken from the test \fIscript\fR\|(s) that can
be found in directory ``t'' of the Bio::UnivAln distribution.
There you will also find a \s-1CGI\s0 script producing some graphics,
which is currently in alpha status: I suspect it needs some
refitting to run on a different server. If you'd like to know more about
multiple alignments, in theory and practice, check out the tutorial at
http://www.techfak.uni-bielefeld.de/bcd/Curric/MulAli/mulali.html )
.Sh "\s-1CREATION\s0 \s-1OF\s0 \s-1ALIGNMENTS\s0"
.IX Subsection "CREATION OF ALIGNMENTS"
Alignments can be constructed from files, (multi-line) strings,
arrays and Bio::Seq objects. Files need to be in a standard format,
as described below, under the header the ALIGNMENT FORMATS entry elsewhere in this document.
.PP
.Vb 1
\&  my $aln = Bio::UnivAln->new('t/alnfile.fasta');
.Ve
The first parameter is regarded as a file name; if you pass
additional parameters, they will overwrite the parameters read in
from the file. You can use named parameters; take a look at
the documentation on the \fInew()\fR method in the appendix for a list of all
parameters, and their names. In the following example, description,
sequence type, and file format are provided. The file format will
relieve Bio::UnivAln from guessing it; however, there are no guarantees if
you bypass Bio::UnivAln's guessing _and_ provide an incorrect file format.
.PP
.Vb 5
\&  $aln = Bio::UnivAln->new(-file=>'t/alnfile.aa',
\&                       -desc=>'Sample alignment',
\&                       -type=>'amino',
\&                       -ffmt=>'raw'      # 1 line in file -> 1 sequence
\&                      );
.Ve
If no description (``\-desc'') is given, a default one will be based on the
file name.  The format type is also the default format for output; if both
differ, you need to specify the input format when you construct the \f(CW$aln\fR
object, and then use the accessor \fIffmt()\fR to set the default output format.
Bio::UnivAln can be passed the aligned sequences directly, using the
named parameter ``\-seqs''. It takes a multi-line string, or any mix of
strings, array references, and Bio::Seq objects:
.PP
.Vb 6
\&  $aln = Bio::UnivAln->new(-seqs=>"TCCCGCGTCAACTG\enTGGTGCTTCAACCG\enACTTG--TCAACTG");
\&  $aln = Bio::UnivAln->new(-seqs=>[$sequence_strg,\e@character_list,$bioSeqObject]);
\&  $aln = Bio::UnivAln->new(-seqs=> ['ACCCGCGTCAACTG',
\&           ['A','G','G','G','G','C','T','T','C','A','A','C','C','G'],
\&           Bio::Seq->new(-seq=>'ACTTG--TCAACTG')
\&         ]);
.Ve
.Sh "\s-1ACCESS\s0 \s-1TO\s0 \s-1THE\s0 \s-1DATA\s0, \s-1AND\s0 \s-1MANIPULATION\s0"
.IX Subsection "ACCESS TO THE DATA, AND MANIPULATION"
The \fIlayout()\fR method returns the sequence in a specified format;
supported formats are listed under the header the ALIGNMENT FORMATS entry elsewhere in this document.
.PP
.Vb 5
\&  $aln->ffmt('fasta');   # set default output format
\&  print "\en aln in default format:\en", $aln->layout();
\&  print "\en aln in raw format:\en", $aln->layout("raw");
\&  print "\en aln in fasta format:\en", $aln->layout("fasta"), "\en";
\&  print "\en aln in MSF format (via readseq):\en", $aln->layout("MSF"), "\en";
.Ve
.Sh "Access by Specifying Boundaries"
.IX Subsection "Access by Specifying Boundaries"
You can calculate slices of alignments in a very flexible way;
interval slices like the intersection of rows 1\-3 and columns 1\-2 are
calculated using \fIseqs()\fR. Here, intersection means that those
elements are returned that are both in rows 1\-3 and in columns 1\-2.
.PP
.Vb 2
\&  $alnSlice = $aln->seqs(1,3,1,2);  # rows 1-3, columns 1-2
\&  $alnSlice = $aln->seqs();  # returns the whole alignment
.Ve
Here's a diagram illustrating the general case, intersecting rows
\&\f(CW$y_lo\fR to \f(CW$y_hi\fR, and columns \f(CW$x_lo\fR to \f(CW$x_hi\fR.
.PP
.Vb 10
\&                $x_lo      $x_hi
\&                 :           :
\&     .. $y_lo ...:...........:.................
\&                 :::::::::::::
\&                 :: SELECTED :
\&                 ::: PART ::::
\&                 :::::::::::::
\&     .. $y_hi ...:::::::::::::.................
\&                 :           :
\&                                            Fig.1
.Ve
Maximal intervals will be assumed if no parameters are provided.
Per default, the first row (sequence) has index 1 (not 0), and the first
column has index 1 (not 0). The latter can be modified using \fInumbering()\fR.
.Sh "Access by Index Lists"
.IX Subsection "Access by Index Lists"
If you desire non-consecutive row / column elements,
you can specify the indices as lists, one list of desired row indices
and one list of desired column indices.
.PP
.Vb 1
\&  $alnSlice = $aln->seqs([1..3], [1,4]);  # rows 1-3, columns 1+4
.Ve
Here, letters in columns 2+3 will not be returned. Another example:
.PP
.Vb 1
\&  $alnSlice = $aln->seqs([3,2,3,1], [1,3..5]);  # rows 3,2,3,1, cols 1,3..5
.Ve
If you specify the empty list (``[]''), all rows/columns will be returned.
The following diagram shows the case where the list of row indices
is [$r1,$r2,$r3,$r4], and the list of column indices is [$c1,$c2,$c3].
.PP
.Vb 11
\&                 :    :          :
\&                 :    :          :
\&     ............*....*..........*.............  $r1
\&                 :    :          :
\&     ............*....*..........*.............  $r2
\&     ............*....*..........*.............  $r3
\&                 :    :          :
\&     ............*....*..........*.............  $r4
\&                 :    :          :
\&                 :    :          :
\&                $c1  $c2        $c3           Fig.2
.Ve
Again, an element is selected for the slice if and only if it lies
in the intersection of a row and a column which are both desired
according to the index lists.
.Sh "Return Values"
.IX Subsection "Return Values"
In the examples above, a string (scalar) is returned; the standard
sequence accessor \fIseqs()\fR always returns a (multi-line)
string in a scalar context. In a list context, it returns an array;
each element of such an array is a reference to another array holding
the letters of one sequence, i.e. one single row.
.PP
.Vb 2
\&  @alnSlice = $aln->seqs([1..3], [1,4]);  # rows 1-3, columns 1+4
\&      for $aref ( @alnSlice ) { print @$aref, "\en"; }
.Ve
If you use the result of an accessor or a utility function in the ``\-seqs''
slot of \fInew()\fR, you may need to force that result into a scalar
context, because the accessor, etc, returns a list in a list context,
and the constructor naturally provides such a list context since it expects a
list of parameters.
.PP
.Vb 1
\&  $aln = new Bio::UnivAln(-seqs=>scalar($aln2->seqs()));
.Ve
In the example above, the list-context return value of
\&\f(CW\*(C`$aln2\->seqs()\*(C'\fR, i.e. the list of rows of \f(CW$aln2\fR,
would be fed one by one as additional parameters into the constructor,
if you didn't ``protect'' it by \fIscalar()\fR. You will be warned about the problem
because Bio::UnivAln detects any named parameters that it can't use.
.Sh "Access by Id"
.IX Subsection "Access by Id"
(The following access method is currently in alpha status, it may need
some revision until the code is fully released.)
.PP
Any list of desired row/column indices can be replaced by a hash of desired
ids, which are recognized if they are in the object's own list of row or column
ids. You need to pass a reference to a hash that has one key, ``ids'',
and one value, which is a string containing the ids seperated by `` ''(blank) :
.PP
.Vb 1
\&  $alnSlice = $aln->seqs({ids=>'SeqA SeqB'},{ids=>'ColA ColB ColC'});
.Ve
Row (sequence) ids are automatically extracted when reading fasta files and
Bio::Seq objects. Otherwise, they are set to the default numerical index list,
like (1..20) if the alignment has 20 rows. Since there's currently no way
to extract column (site) ids (none of the supported formats has this feature),
these always hold the default numerical indices. However, both lists
may be set using the accessors \fIrow_ids()\fR and \fIcol_ids()\fR. Note that arbitrary
numbering schemes can be supported this way.
.Sh "Access by Selector Function"
.IX Subsection "Access by Selector Function"
Finally, you can specify a function such that \fIseqs()\fR returns exactly
those letters which lie in a row (or column) for which your function returns
true. E.g. \fIhas_purine()\fR returns true if the row/column contains A, a, T, t, R,
or r; the following \f(CW$alnSlice\fR will contain only columns that have
one of these letters in them.
.PP
.Vb 6
\&      sub has_purine {
\&        my $str = join "", @{ $_[0] };
\&        if ($str =~ /[AaGgRr]+/) {return 1;} else {return 0;}
\&      }
\&  $alnSlice = $aln->seqs([1..3], \e&has_purine); # rows 1-3, and from these
\&      # only the columns for which has_purine returns 1
.Ve
Similarly, the list of row indices, [1..3], could be replaced by a
function, which is then used to designate the desired rows. (It has the
same role that the expression \s-1EXPR\s0 has in the Perl code template
\&\fBgrep \s-1EXPR\s0, \s-1LIST\s0\fR, see the perlfunc manpage. Bio::UnivAln also provides
the equivalent to \fBmap \s-1EXPR\s0, \s-1LIST\s0\fR; this ``Mapping'' will be discussed soon.)
.PP
In other words, any list of indices can be replaced by the reference to a
function r or c. The function then selects those elements (*) that lie in
a row or column which meets a criterion, returning true if the criterion
is met, and false otherwise.
If both lists of indices are replaced by functions, the picture is like this:
.PP
.Vb 12
\&                 :    :          :
\&                 :    :          :
\&     ............*....*..........*.............  r(row) = true
\&                 :    :          :
\&     ............*....*..........*.............  r(row) = true
\&     ............*....*..........*.............  r(row) = true
\&                 :    :          :
\&     ............*....*..........*.............  r(row) = true
\&                 :    :          :
\&                 :    :          :
\&           c(column) c(column)  c(column)
\&            = true    = true     = true       Fig.3
.Ve
The function out_fasta observes all types of selectors that \fIseqs()\fR does,
and returns the result in fasta format :
.PP
.Vb 1
\&  print "\en aln in fasta format:\en", $aln->out_fasta([1..3],\e&has_purine), "\en";
.Ve
.Sh "Mapping functions onto Sequences and Columns"
.IX Subsection "Mapping functions onto Sequences and Columns"
You can map a function onto selected rows or columns, and receive the
results as a list:
.PP
.Vb 2
\&  @resSlice = $aln->map_r(\e&has_purine, [1..3]); # 1,0,1 if row 1+3 has purine
\&  @resSlice = $aln->map_c(\e&has_purine, [1,4]); # 1,0 if column 1 has purine
.Ve
As you may expect, maximal index lists (i.e, all rows / all columns) will be
assumed if no second parameter is provided. In the same way as before,
any one if the index lists may be replaced by a hash of ids, or a selector
function. In the section on the User-defined Utility Functions entry elsewhere in this document, \fImap_r()\fR and
\&\fImap_c()\fR are used to implement user-defined consensus, reverse, complement, etc.
.PP
By the way, the following map is the same as \f(CW@alnSlice\fR = \f(CW$aln\fR->seqs([1..3])
since mapping the identity function ``sub id { return \f(CW@_\fR }''
to desired row/column subsets and collecting the result is just like slicing.
.PP
.Vb 1
\&  @alnSlice = $aln->map_r(\e&id, [ 1..3 ]);
.Ve
The number of rows/columns of an alignment can be obtained by using
\&\fIheight()\fR and \fIwidth()\fR respectively. Ids and descriptions of rows (sequences)
and columns (sites) can be manipulated using \fIrow_ids()\fR, \fIcol_ids()\fR,
\&\fIrow_descs()\fR and \fIcol_descs()\fR. Be \fBwarned\fR that these accessors just return
a reference to the array of ids/descriptions; if you'd like to process
the array without changing the object's data, you need to create your
own copy. This decision was taken because especially the result of \fIcol_ids()\fR
can be huge, and for a lot of applications a deep copy is unnecessary.
.Sh "Inplace Manipulation"
.IX Subsection "Inplace Manipulation"
Slices can be applied to the object itself, replacing the old alignment
by a new one that is sliced from the old ('inplace' manipulation).
This is particularly useful is the alignment is large. The row (sequence)
and column (site) ids are taken over from the old alignment. They are
used as the lookup tables for the Access by Id entry elsewhere in this document, and available via \fIrow_ids()\fR
and \fIcol_ids()\fR.
.PP
The following code sets the ``inplace'' flag, and overwrites the current
alignment with the rows named A and B, and columns 1\-6:
.PP
.Vb 3
\&  $aln->inplace(1);
\&  $aln->seqs({ids=>'A B'},[1..6]);
\&  $aln->inplace(0);
.Ve
\&'inplace' manipulation is also available for most utility functions below,
with the notable exception of \fIconsensus()\fR. A full list is given in the
description of \fIinplace()\fR, see the Appendix.
.Sh "\s-1UTILITY\s0 \s-1FUNCTIONS\s0 \s-1LIKE\s0 \s-1CONSENSUS\s0, \s-1AND\s0 \s-1REVERSE\s0 \s-1COMPLEMENT\s0"
.IX Subsection "UTILITY FUNCTIONS LIKE CONSENSUS, AND REVERSE COMPLEMENT"
In the following paragraph, Bio::UnivAln's direct support for utility
functions like consensus, (in)variable sites, gap-free sites, reverse,
complement, and reverse complement is explained.
.PP
.Vb 1
\&  $resSlice = $aln->consensus();
.Ve
calculates the consensus of the columns, i.e. those columns for which there
exists a letter which has an absolute majority of 75% or more. The letter
\&'!' designates the case that no consensus is given.
To bypass the default threshold, write
.PP
.Vb 1
\&  $resSlice = $aln->consensus(0.6);
.Ve
Note that for values smaller or equal to 0.5, two letters may have an equal
(relative) majority, and the tie is currently broken arbitrarily.
Thresholds larger than or equal to 1 imply that the site that has a
consensus letter must be invariant.
.PP
.Vb 1
\&  $resSlice = $aln->consensus(1, [1..10]);
.Ve
Just like \fIseqs()\fR and \fImap_c()\fR/\fImap_r()\fR, \fIconsensus()\fR can be passed a reference
to a hash of desired column ids, a function that selects the columns,
or the desired column indices themselves. (Here, it's columns 1 to 10.
Internally, \fImap_c()\fR is used to implement \fIconsensus()\fR.)
.PP
The methods \fIvar_sites()\fR and \fIinvar_sites()\fR are using \fIconsensus()\fR,
just checking whether there is a consensus letter ('invariable'),
or not ('variable'). Naturally, the default threshold is 1, i.e.
sites must be truly invariable (100% majority of 1 letter),
or truly variable (strictly less than 100% majority). Per default,
\&\fIvar_sites()\fR and \fIinvar_sites()\fR return a \fBmultiline string of rows\fR (sequences),
with elements from the desired columns (sites) only. They do \fBnot\fR
return the alignment in a column-by-column fashion ! Also, don't be confused
by the possibilty to specify a list of desired row indices / ids, or
a selector function: It just constrains the output further, without
influencing which columns are selected. (Internally, \fIseqs()\fR is used to
implement these functions; it is passed a row selector, and a function
that returns true if there is a consensus letter.)
.PP
.Vb 7
\&  $resSlice = $aln->var_sites();
\&  $resSlice = $aln->invar_sites();
\&  $resSlice = $aln->var_sites(0.6, [1,3]); # no columns with >= 60% majority
\&                                     # of one letter; also, print rows 1+3 only
\&  $resSlice = $aln->invar_sites(0.6, [1,3]);  # only columns with >= 60% maj.
\&  $resSlice = $aln->no_allgap_sites([1,3]); # exclude sites that only have gaps
\&  $resSlice = $aln->gap_free_sites([1,3]); # exclude sites that have >= 1 gaps
.Ve
In a similar fashion, the last example selects gap-free columns, and from
those only prints the elements that happen to be in rows 1+3.
All these utilities support the Inplace Manipulation entry elsewhere in this document:
.PP
.Vb 3
\&  $aln->inplace(1);
\&  $aln->var_sites(0.6, {ids=>'1 2'});
\&  $aln->inplace(0);
.Ve
The utilities \fIreverse()\fR, \fIcomplement()\fR, and \fIrevcom()\fR also allow
for the Inplace Manipulation entry elsewhere in this document, and again you can
specify the rows which shall form the new alignment by overwriting the
old, or be returned as reverse'd, complement'ed, or reverse complement'ed :
.PP
.Vb 3
\&  $resSlice = $aln->reverse([1,3]);
\&  $resSlice = $aln->complement([1,3]);
\&  $resSlice = $aln->revcom([1,3]);
.Ve
If an inplace manipulation reverses column order, e.g. in the case of
\&\fIreverse()\fR, this will be reflected in the column ids available via \fIcol_ids()\fR.
Note that complement is defined according to the \s-1IUPAC\s0 code,
using the same substitutions that Bio::Seq uses, such that results
obtained for e.g. Amino Acid sequences are probably nonsensical.
.PP
For all functions that have ``sites'' in their name, a corresponding
``inds'' function is available that returns the relevant array of indices
instead of the sites themselves:
.PP
.Vb 2
\&  $indices = $aln->var_inds(); # array of indices of the variable sites
\&  $indices = $aln->no_allgap_inds([1,3]);
.Ve
Finally, the original sequences (without gaps) are available via \fIremove_gaps()\fR.
.PP
.Vb 1
\&  $some_original_sequences = $aln->remove_gaps([1,3]);
.Ve
In a list context, all these utility functions return an array of array
references, just like \fIseqs()\fR; the exception is \fIconsensus()\fR, which then returns
a simple array of consensus letters.
.Sh "\s-1ALIGNMENT\s0 \s-1FORMATS\s0"
.IX Subsection "ALIGNMENT FORMATS"
The directly supported formats are fasta and raw (1 line in file -> 1 sequence,
where \*(L"\en\*(R" (newline) is the delimiter.) If available (see the INSTALLATION manpage),
readseq is used to parse and write \s-1PIR/CODATA\s0, \s-1MSF/GCG\s0 and \s-1PAUP/NEXUS\s0
formats; \s-1ASN\s0.1 does not seem to work reliably. Clustal is used to parse
in clustal format, if available.
.Sh "\s-1ADVANCED\s0 \s-1STUFF\s0"
.IX Subsection "ADVANCED STUFF"
An exhaustive list of accessors and methods is given in the appendix.
E.g., Alignments may be copied using \fIcopy()\fR, and compared for equality modulo
gaps with \fIequal_nogaps()\fR.
.PP
Bio::UnivAln doesn't really care whether the sequences passed in are indeed
from an alignment (i.e. have the same length); sequence bags (i.e. multisets
of sequences where the same element may occur more than once) are
therefore handled, too. However, you need to be careful with some
methods (e.g. the accessor \fIseqs()\fR, and \fIwidth()\fR) because their default
behavior may depend on inspecting the first sequence only (or the first
requested sequence, if this information is available \*(-- new feature in 1.006) :
If you use \fIseqs()\fR on a sequence bag, and don't provide the number of columns
explicitly, you may be surprised to find out that the length of
the first sequence is used as the default length, and not the length
of the longest sequence. \fIwidth()\fR uses the same heuristic.
.PP
You can add gap symbols to the elements of a multiset so that
each element takes the length of the longest sequence by calling
\&\fIequalize_length()\fR; you can even pad more gap characters by specifying
the new width yourself, as an argument to \fIequalize_length()\fR.
.PP
If you need to have the alignment in an intermediate form, i.e.
neither an array of array references, nor a single multiline string, but
an array of strings, just request the output as a multiline string, and split
it on \*(L"\en\*(R". For example, to just extract a single column, you can do
.PP
.Vb 1
\&  @col = split "\en", $aln->seqs([],[$colindex]);
.Ve
Checking an alignment for characters that should not be there according
to the Alignment Type is currently not well-supported; see \fIalphabet_check()\fR
for a _preliminary_ way of doing manual checkup, though.
.PP
The hash referenced by \f(CW$names\fR stores {loc,name}
pairs of other database locations and corresponding names where
the alignment is located.
Currently, loc and name must both be set as text, and must consist
entirely of a string matching the regexp /^[A-Za-z]\ew*$/.  That is, they must
be a single \*(L"word\*(R" of at least one character, without a leading underscore.
This restriction is not enforced, but code which deviates is subject to
break in future releases.  Note also that the object may place any other
sort of items in the name string, so users of this hash should not rely on
accessing entries conforming the requirements above.
.Sh "Alignment Types"
.IX Subsection "Alignment Types"
The supported sequence types and corresponding alphabets are the same
as reported in the documentation of the Bio::Seq object: ``dna'', ``rna'',
and ``amino''. They are carried along without much checking, etc.
.Sh "User-defined Utility Functions"
.IX Subsection "User-defined Utility Functions"
Here are some user-defined auxiliary functions which can be applied to
rows and columns of an alignment; this technique can be used if
no appropriate built-in functions are available, or if you don't want
to use them.
.PP
maj_dominance returns false if all letters in a column/row are the same.
.PP
.Vb 6
\&      sub maj_dominance {
\&        my $str = join "", @{ $_[0] };
\&        my $first_res = @{ $_[0] }[0];
\&        $str =~ s/$first_res//g;
\&        if ($str) {return 0;} else {return 1;}
\&      }
.Ve
consensus returns the letter that has the (relative) majority among all
residues, if it exceeds a certain threshold. (For simplicity, the threshold
is hard-wired.)
.PP
.Vb 9
\&      sub consensus {
\&        my @chars = @{ $_[0] };
\&        my %temp = ();
\&        my $threshold = 0.34;  # more than 1/3
\&        my @list = sort { $temp{$a}<=>$temp{$b} }
\&                        grep ++$temp{$_} >= $threshold * ($#chars+1), @chars;
\&          # In case of a tie, it's not specified which residue is in $list[-1]
\&        return (defined($list[-1]) ? $list[-1] : '!');
\&      }
.Ve
reverse_ and complement implement reversing a sequence (note the
underscore; I'm looking for better ways to implement function passing),
and complementing it according to \s-1IUPAC\s0 conventions.
.PP
.Vb 8
\&      sub reverse_ {
\&        return [ reverse @{ $_[0] } ];
\&      }
\&      sub complement {
\&        my $str = join "", @{ $_[0] };
\&        $str =~ tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/;
\&        return [ split "", $str ];
\&      }
.Ve
Here, the functions above are applied:
.PP
.Vb 2
\&  @resSlice = $aln->map_c(\e&maj_dominance);
\&  print "\enDominated sites:\en", @resSlice, "\en";
.Ve
.Vb 3
\&  @resSlice = $aln->map_c(\e&consensus);
\&  @resSlice = $aln->map_c(\e&consensus, \e&has_purine);
\&  print "\enConsensus of the columns that have purine\en", @resSlice, "\en";
.Ve
.Vb 1
\&  @resSlice = $aln->map_r(\e&reverse_);
.Ve
.Vb 1
\&  @resSlice = $aln->map_r(\e&complement);
.Ve
You can also parametrize your functions by using ``closures'' (See
``Programming Perl'', 2nd Ed., p.253). Basically, you set up a function
that has the parameter built into it, and pass around the reference to
that function. Here's a function that does the set-up:
.PP
.Vb 11
\&      sub _setup_consensus_with_threshold {
\&        my $threshold = shift;
\&        return sub {
\&          my @chars = @{ $_[0] };
\&          my %temp = ();
\&          my @list = sort { $temp{$a}<=>$temp{$b} }
\&                          grep ++$temp{$_} >= $threshold * ($#chars+1), @chars;
\&            # In case of a tie, it's not specified which residue is in $list[-1]
\&          return (defined($list[-1]) ? $list[-1] : 'N');
\&        }
\&      }
.Ve
Here, you create an instance of the function, incl. the parameter.
\&\f(CW$consensus\fR holds a reference to the new instance.
.PP
.Vb 1
\&  my $consensus = _setup_consensus_with_threshold(0.75);
.Ve
and finally, you pass the reference to the function around, e.g. to \fImap_c()\fR.
.PP
.Vb 1
\&  @resSlice = $aln->map_c(\e&$consensus);
.Ve
(You can do pretty cute tricks using closures, e.g. you can set a counter
to 1 in the setup function, and increment it in the ``real'' function.)
.SH "Bio::UnivAln Guts"
.IX Header "Bio::UnivAln Guts"
Currently, the object hash has the following keys. This may be subject
to change; in particular the alignment data may at some point be stored
more efficiently in a \s-1PDL\s0 (Perl Data Language) array.
.PP
.Vb 26
\&  $self->{'seqs'}   : An array of array references, each of which holds
\&                    one sequence of the alignment
\&  $self->{'id'}     : String specifying the ID; shall be in \ew+ (i.e. composed
\&                    of characters in [a-zA-Z_0-9]; only \eS+ is enforced, though)
\&  $self->{'desc'}   : String giving a description, (later) to be formatted
\&                    according to $descffmt
\&  $self->{'names'}  : A reference to a hash which stores {loc,name} pairs of
\&                    other database locations and corresponding names where
\&                    the alignment is located.
\&  $self->{'row_ids'}: A reference to an array which stores row (sequence) ids
\&  $self->{'col_ids'}: Same as $self->{'row_ids'}, for the columns (sites)
\&  $self->{'row_descs'}: A reference to an array which stores row (sequence)
\&                    descriptions
\&  $self->{'col_descs'}: Same as $self->{'row_descs'}, for the columns (sites)
\&  $self->{'numbering'}: The offset of the first column, an integer
\&  $self->{'type'}   : The type of the alignment, concatenated from the molecule
\&                    type (see L<Alignment Types>) and a flag that is not
\&                    currently used, but intended to flag sequence bags
\&  $self->{'ffmt'}   : alignment format, see L<ALIGNMENT FORMATS>.
\&  $self->{'descffmt'}: format of $desc; right now this should be ``raw''
\&                    or ``fasta'' which just implies that no specific
\&                    format is being followed, any text is allowed
\&                    excluding ``\en''(newline). More support is planned.
\&  $self->{'inplace'}: Flag which is set to true if accessors (and utility
\&                    functions) should make the modification to the object
\&                    itself, and just return true on success. (See inplace().)
.Ve
Some more helpful comments...
In Perl, false is 0 or "", true is everything else.
Not all internal functions have a \s-1POD/HTML\s0 documentation.
If you read the code of this module, you need to be familiar with
map and grep...
.SH "TO-DO"
.IX Header "TO-DO"
Soon:
.PP
Better handling of access, copying and slicing of \f(CW\*(C`$self\->{'row_ids'}\*(C'\fR, etc.
Add pointer to a UnivAln demo page based on the draft at
http://www.techfak.uni-bielefeld.de/bcd/Perl/Bio/Docs/phylosnapshot.html.
Fix \fIalphabet_check()\fR (current workaround cannot be generalized),
Fix UnivAlnAlph{UnivAlnType{\*(L"unknown\*(R"}} (current setting is not so nice;
what's the easiest way to set it to all word characters ?),
Support more formats, especially Nexus,
Improved sequence alphabet support; not just providing a function
\&\fIalphabet_check()\fR for manual checking.
Then, maybe use strings to represent alphabets.
Test and document \fIaln()\fR for returning a slice as an alignment.
.PP
Later:
.PP
Validity marker for correctly initialized/manipulated objects.
Assign _unique_ IDs if none are provided.
Functions like \fIhas_seqs()\fR, etc.
Using `undef' during initialization, and functions for regaining such a state.
Use Perl Data Language ?!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
How is this for a maximum of disclaiming warranty ? In short, I'm developing
this module in my spare time and it's for free, don't sue me :\-)
.PP
.Vb 6
\& IN NO EVENT SHALL THE GLOBEWIDE NETWORK ACADEMY, THE VIRTUAL SCHOOL OF NATURAL
\& SCIENCES, THE AUTHOR OR THE UNIVERSITY OF BIELEFELD BE LIABLE TO ANY PARTY
\& FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
\& OUT OF THE USE OF THIS CODE, EVEN IF THE GLOBEWIDE NETWORK ACADEMY,
\& THE VIRTUAL SCHOOL OF NATURAL SCIENCES, THE AUTHOR OR THE UNIVERSITY OF
\& BIELEFELD HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.Ve
.Vb 6
\& THE GLOBEWIDE NETWORK ACADEMY, THE VIRTUAL SCHOOL OF NATURAL SCIENCES, THE
\& AUTHOR AND THE UNIVERSITY OF BIELEFELD SPECIFICALLY DISCLAIM ANY WARRANTIES,
\& INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
\& AND FITNESS FOR A PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN
\& "AS IS" BASIS, AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCEE,
\& SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Copyright (c) 1996, 1997, 1998 Georg Fuellen. All Rights Reserved.
Some pieces of the code were contributed by Steven E. Brenner,
Richard Resnick and Chris Dagdigian. Thanks !!!!
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other Bioperl modules.
Send your comments and suggestions preferably to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 2
\&    bioperl-l@bioperl.org          - General discussion
\&    http://bio.perl.org/MailList.html             - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track the bugs and
their resolution. Bug reports can be submitted via email or the web:
.PP
.Vb 2
\&    bioperl-bugs@bio.perl.org
\&    http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Georg Fuellen
.PP
Technische Fakultaet \- \s-1AG\s0 Praktische Informatik,
Universitaet Bielefeld,
D-33501 Bielefeld,
Germany,
georg.fuellen@uni-bielefeld.de
.PP
http://www.techfak.uni-bielefeld.de/~fuellen/
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Steven E. Brenner, Steve A. Chervitz, Michael Constant, Richard Resnick,
Chris Dagdigian, Lew Gramer [more to follow]
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 1
\& Bio::Seq.pm - The biosequence object
.Ve
.Vb 3
\& http://bio.perl.org/Projects/modules.html  - Online module documentation
\& http://bio.perl.org/Projects/SeqAlign/     - Bioperl sequence alignment project
\& http://bio.perl.org/                       - Bioperl Project Homepage
.Ve
.SH "REFERENCES"
.IX Header "REFERENCES"
If you'd like to acknowledge use of Bio::UnivAln in your work, please cite
.PP
Fuellen, G. (1997). Bio::UnivAln \- bioperl alignment object [WWW-Document].
\&\s-1URL\s0 http://www.techfak.uni-bielefeld.de/bcd/Perl/Bio/welcome.html
.PP
And please drop me a note :\-)
An article for the Perl Journal is planned. The page is mirrored at
.PP
http://merlin.mbcr.bcm.tmc.edu:8001/bcd/Perl/Bio/welcome.html
http://www.biotech.ist.unige.it/bcd/Perl/Bio/welcome.html
.SH "REVISION HISTORY"
.IX Header "REVISION HISTORY"
Version 1.000 on 12 Feb 1997.
.PP
Version 1.001 on 19 Feb 1997. Fixed a bug that
triggered \fI_rowbounds()\fR and \fI_colbounds()\fR to use maximal index lists
whenever the first index in an index list was 0. New example in \s-1POD:\s0
.PP
.Vb 1
\&    $aln = new Bio::UnivAln(-seqs=>scalar($aln2->var_sites()));
.Ve
Internal: Now avoiding any global parameter passing by using closures,
for the utility functions.
.PP
Version 1.002 on 21 Feb 1997. Renamed the module to UnivAln, see the
discussion (Feb 1997) in the vsns-bcd-perl mailing list archive.
Fixed hopefully all problems in \fIout_graph()\fR, all of them triggered by
bugs/features of \s-1PGPLOT\s0.
.PP
Version 1.003 on 25 Feb 1997. Added \s-1POD\s0 on using closures.
Moved \fIout_graph()\fR into the cgi-script t/univaln.cgi (this is alpha-code !)
so that ``use \s-1PGPLOT\s0'' is no longer required.
.PP
Version 1.004 on 13 Mar 1997. Fixed bug with reading fasta files.
Changed file format identifiers ``Fasta'' and ``Raw'' to ``fasta'' and ``raw''.
Added support for arbitrary numeration schemes by providing access by name/id
for rows (sequences) and columns (sites).
Made \fI_arys()\fR and \fI_strs()\fR accept same row/column designations like \fIseqs()\fR.
Added 'inplace' manipulation for slicing and most utilities.
Improved speed a little. Deriving default description string from file name,
if available.
.PP
Version 1.005 on 18 Jun 1997. Using simple filename (``basename'') as default
decription. Changed type identifiers ``Unknown'', ``Dna'', ``Rna'', ``Amino''
to ``unknown'', ``dna'', ``rna'', ``amino''. The old acronyms should still
be supported for the forseeable future.
.PP
Version 1.006 on 15 Dec 1997. Added function \fIno_allgap_sites()\fR; \fIout_fasta()\fR
now accepts same row/column designations like \fIseqs()\fR. For advanced users:
the \fIwidth()\fR of sequence bags can now be controlled by supplying the index of
the row whose width is taken \*(-- by default the width of the first row is used.
.PP
Version 1.007 on 15 Mar 1998.
* Added functions that return indices instead of actual sequence data:
\&\fIvar_inds()\fR, \fIinvar_inds()\fR, \fIgap_free_inds()\fR, \fIunknown_free_inds()\fR,
\&\fIspecial_free_inds()\fR and \fIno_allgap_inds()\fR return the indices of
(in)variable, gap-free, unknown-free, gap+unknown-free and non-gap-only
columns; they are the counterparts of \fIvar_sites()\fR, etc.
* Added \fIremove_gaps()\fR to return ungapped (original) sequence data
* Added \fIequal_no_gaps()\fR to check for equality ignoring gaps
* Added \fIequalize_lengths()\fR for padding a sequence bag with gaps
such that all rows have equal length (current procedure is slow)
* The default id is now ``_'' (was: ``No_Id_Given'')
* Internal functions \fI_rowbounds()\fR and \fI_colbounds()\fR now return indices
from the user's perspective, but \s-1WITHOUT\s0 substracting offset.  Instead,
all functions subtract offset after applying \fI_rowbounds()\fR/\fI_colbounds()\fR
.PP
Version 1.008 on 13 May 1998.
* Added readseq conversion support, making it possible to read and write
the following formats: \s-1MSF\s0, Paup, PIR/Codata, \s-1ASN\s0.1. (\s-1ASN\s0.1 was not
parsed successfully: readseq seems to be unable to read in its own \s-1ASN\s0.1
output). Technically, readseq is now used to parse files that have been
processed as ``raw'' before; now ``raw'' format is recognized using the
expression /^[A-Z_0\-9$_GAP_SYMBOL$_UNKN_SYMBOL\es]+$/im, i.e. the file
may only have alphanumerical characters, gap and unknown-symbol, and
whitespace. If commata, etc, are detected, readseq is used for parsing.
Readseq itself seems to be unable to detect ``raw'' format in some cases,
causing weird results.
* Added Clustal support for parsing; still to be tested and documented.
.PP
Version 1.009 on 25 May 1998.
* The module can now be ``built'' in the standard way (perl Makefile.PL, etc).
.SH "APPENDIX"
.IX Header "APPENDIX"
Please note that functions starting with an underscore (``_'') are
intended for internal use only: Use them only if you know what you're
doing :\-)
.Sh "\fInew()\fR"
.IX Subsection "new()"
.Vb 47
\& Usage    :  $myAln = Bio::UnivAln->new($file,$seqs,$id,$desc,$names,
\&                        $row_ids,$col_ids,$row_descs,$col_descs,$numbering,$type,
\&                        $ffmt,$descffmt,$inplace);
\&                           - or -
\&             $myAln = Bio::UnivAln->new(-file=$file,
\&                                  -seqs=>$seqs,
\&                                  -id=>$id,
\&                                  -desc=>$desc,
\&                                  -names=>$names,
\&                                  -row_ids=>$row_ids,
\&                                  -col_ids=>$col_ids,
\&                                  -row_descs=>$row_descs,
\&                                  -col_descs=>$col_descs,
\&                                  -numbering=>$numbering,
\&                                  -type=>$type,
\&                                  -ffmt=>$ffmt,
\&                                  -descffmt=>$descffmt,
\&                                  -inplace=>$inplace);
\& Function : The constructor for this class, returns a new object.
\& Returns  : Bio::UnivAln object
\& Argument : $file: file from which the alignment data can be read; all
\&                   the other arguments will overwrite the data read in.
\&                   (see ``Alignment Formats'')
\&            $seqs: EITHER a reference to a list of either Bio::Seq objects, or
\&                   arrays of letters, or strings, or any mix of these,
\&                   OR a single (multi-line) string
\&            $id: String specifying the ID.
\&            $desc: String giving a description, (later) to be formatted
\&                   according to $descffmt
\&            $names:A reference to a hash which stores {loc,name} pairs of
\&                   other database locations and corresponding names where
\&                   the alignment is located. (See L<ADVANCED STUFF>).
\&            $row_ids  :A reference to an array which stores row (sequence) ids.
\&            $row_descs:A reference to an array which stores row (sequence)
\&                    descriptions
\&            $col_ids:  Same as $self->{'row_ids'}, for the columns (sites)
\&            $col_descs:Same as $self->{'row_descs'}, for the columns (sites)
\&            $numbering: The offset of the first column
\&            $type: The type of the alignment, see ``Alignment Types''.
\&            $ffmt: alignment format, see ``Alignment Formats''.
\&            $descffmt: format of $desc; right now this should be ``raw''
\&                       or ``fasta'' which just implies that no specific
\&                       format is being followed, any text is allowed
\&                       excluding ``\en''(newline).
\&            $inplace: Flag which is set to true if accessors and utility
\&                      functions should make the modification to the object
\&                      itself, and just return true on success. See inplace().
.Ve
.Sh "\fI_initialize()\fR"
.IX Subsection "_initialize()"
.Vb 5
\& Usage    : n/a (internal function)
\& Function : Assigns initial parameters to a blessed object.
\& Returns  : 1 on success
\& Argument : As Bio::UnivAln->new, allows for named or listed parameters.
\&            See ->new for the legal types of these values.
.Ve
.Sh "\fI_rearrange()\fR"
.IX Subsection "_rearrange()"
.Vb 10
\& Usage    : n/a (internal function)
\& Function : Rearranges named parameters to requested order.
\& Returns  : @params - an array of parameters in the requested order.
\& Argument : $order : a reference to an array which describes the desired
\&                     order of the named parameters.
\&            @param : an array of parameters, either as a list (in
\&                     which case the function simply returns the list),
\&                     or as an associative array (in which case the
\&                     function sorts the values according to @{$order}
\&                     and returns that new array.
.Ve
.Sh "\fI_rowbounds()\fR"
.IX Subsection "_rowbounds()"
.Vb 8
\& Usage    : $corrected_bounds = $aln->_rowbounds($uncorrected_bounds);
\& Function : create default row index list if necessary,
\&            create row index list if specified by a hash of ids or
\&            by a selector function that acts on rows and returns true/false,
\&            check row index list for bounds errors,
\&            NO LONGER DONE IN VERSION 1.007 AND HIGHER: substract offset of 1.
\& Returns  : reference to corrected row index list
\& Argument : reference to uncorrected row index list
.Ve
.Sh "\fI_colbounds()\fR"
.IX Subsection "_colbounds()"
.Vb 11
\& Usage    : $corrected_bounds = $aln->_colbounds($uncorrected_bounds);
\& Function : create default column index list if necessary,
\&            create column index list if specified by a hash of ids or
\&            by a selector function that acts on columns and returns true/false,
\&            check column index list for bounds errors,
\&            NOT IN 1.007 and higher: substract offset (according to numbering scheme).
\& Returns  : reference to corrected column index list
\& Argument : reference to uncorrected column index list
\&            reference to row index list: its first row is used to
\&            provide the width of the alignment considered, which matters
\&            if the alignment is really a sequence bag
.Ve
.Sh "\fI_fixbounds()\fR"
.IX Subsection "_fixbounds()"
.Vb 15
\& Usage    : ($corrected_rowbounds,$corrected_colbounds) =
\&               $aln->_fixbounds($uncorrected_rowbounds,$uncorrected_colbounds);
\&                    OR
\&            ($corrected_rowbounds,$corrected_colbounds) =
\&               $aln->_fixbounds($firstpos1,$lastpos1,$firstpos2,$lastpos2)
\& Function : Convert unfixed index list information into the standard internal
\&            one, allowing as input either max. 2 references or max. 4 boundary
\&            coordinates (2 coord. for row indices and 2 for column indices).
\&            Call functions to create maximal default index lists if needed,
\&            to create index lists if specified by a hash of ids or by a selector
\&            function that acts on rows/columns and returns true/false,
\&            to check index lists for bounds errors, and to substract offsets.
\& Returns  : 2 references to corrected index lists
\& Argument : EITHER max. 2 references to uncorrected index lists,
\&            OR max. 4 boundary coordinates (integers)
.Ve
.Sh "\fI_select()\fR"
.IX Subsection "_select()"
.Vb 6
\& Usage    : @alnSlice = $aln->_select($rrowsel2,$rcolsel2);
\& Function : select elements from the 2-dimensional array $self->{'seqs'}
\&            using index lists
\& Returns  : array of references to array of characters
\& Argument : 2 index lists, one for the rows and one for the columns,
\& Comment  : Here's a diagram of dependencies of some methods relying on _select:
.Ve
.Vb 7
\&                       seqs()
\&                      /    |
\&                    |/_   \e|/
\&                _arys() <-- _strs()
\&                  |
\&                 \e|/
\&               _select()
.Ve
.Sh "\fI_arys()\fR"
.IX Subsection "_arys()"
.Vb 5
\& Usage    : @alnSlice = $aln->_arys([$row1,$row2,$rowx],[col1,$col2,$colx])
\&              (other usages see seqs())
\& Function : Same as seqs(), except that an array is returned always
\& Returns  : array of references to array of characters
\& Argument : Same as seqs()
.Ve
.Sh "\fI_strs()\fR"
.IX Subsection "_strs()"
.Vb 5
\& Usage    : $alnSlice = $aln->_strs([$row1,$row2,$rowx],[col1,$col2,$colx])
\&              (other usages see seqs())
\& Function : Same as seqs(), except that a multiline string is returned always
\& Returns  : multiline string (including newline characters)
\& Argument : Same as seqs()
.Ve
.Sh "\fIseqs()\fR"
.IX Subsection "seqs()"
.Vb 39
\& Usage    : (1) $alnSlice = $aln->seqs($firstpos1,$lastpos1,$firstpos2,$lastpos2)
\&            (2) $alnSlice = $aln->seqs([$row1,$row2,$rowx],[col1,$col2,$colx])
\&            (3) $alnSlice = $aln->seqs(\e&function_of_row,\e&function_of_column)
\&            (4) $alnSlice = $aln->seqs({ids=>'r1 r2 r3'},{ids=>'c1 c2 c3'})
\&               [ (2),(3) and (4) can be intermixed ]
\& Function : (1) Returns part of an alignment, from row $firstpos1 to row
\&            $lastpos1, and from column $firstpos2 to column $lastpos2
\&            Missing parameters are replaced by default (maximal possible)
\&            values, where the length of the first row of the _returned_ (*)
\&            `alignment' determines the default length in case the alignment is
\&            really a sequence bag. ((*) is a new feature in 1.006.)
\&            (2) Returns part of an alignment, i.e. those elements that lie
\&            in a row designated by an index from the first list
\&            ([$row1,$row2,$rowx]), and at the same time lie in a column
\&            designated in the second list ([col1,$col2,$colx]).
\&            The empty list (``[]'') is replaced by default (maximal possible)
\&            values, where the length of the first row of the _returned_
\&            `alignment' determines the default length in case the alignment is
\&            really a sequence bag. (Note that the first element
\&            of rows/columns has index 1 per default.)
\&            (3) Instead of an index list, a function acting on a row / column
\&            may be supplied; whenever the function returns true, the
\&            row / column is designated.
\&            (4) Instead of an index list, a hash of ids may be supplied;
\&            the ids are looked up in the alignment's list of row (sequence)
\&            ids / list of column (site) ids. The former list may be set
\&            during the construction of the alignment (e.g. it may be read
\&            from the fasta file, or the Bio::Seq objects), or it may be
\&            manipulated using row_ids(). col_ids() sets the the latter list.
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : (1) $firstpos1,$lastpos1,$firstpos2,$lastpos2 (all integers; note
\&            that the first element of rows/columns has index 1 per default.)
\&            (2-4) 2 selectors, one for the rows and one for the columns,
\&            each of which may be a reference to a list of indices, or a
\&            reference to a hash that has the format ``{ids=>'id1 id2 idx'}''
\&            where ids is the mandatory key, and the value is a string
\&            containing the desired ids, seperated by `` '' (space), or a
\&            function that acts on a list and returns true/false.
.Ve
.Sh "\fI_map_r()\fR"
.IX Subsection "_map_r()"
.Vb 8
\& Usage    : n/a (internal function)
\& Function : apply a row function to selected rows,
\&            then return the list of all return values
\& Returns  : list of all return values
\& Argument : $rowf: Reference to the function that is applied to selected rows,
\&            its results are put into a list and returned.
\&            $rrowsel: Reference to the selector designating the rows
\&            to which rowf is applied, as in cases (2)-(4) in seqs().
.Ve
.Sh "\fI_map_c()\fR"
.IX Subsection "_map_c()"
.Vb 5
\& Usage    : n/a (internal function)
\& Function : apply a column function to selected columns,
\&            then return the list of all return values
\& Returns  : list of all return values
\& Argument : analogous to _map_r()
.Ve
.Sh "\fImap_r()\fR"
.IX Subsection "map_r()"
.Vb 8
\& Usage    : @resSlice = $aln->map_r($rowf,$rrowsel);
\& Function : apply a function to selected rows,
\&            then return the list of all return values
\& Returns  : list of all return values
\& Argument : $rowf: Reference to the function that is applied to selected rows,
\&            its results are put into a list and returned.
\&            $rrowsel: Reference to the selector designating the rows
\&            to which rowf is applied, as in cases (2)-(4) in seqs().
.Ve
.Sh "\fImap_c()\fR"
.IX Subsection "map_c()"
.Vb 12
\& Usage    : @resSlice = $aln->map_c($colf,$rcolsel,$rrowsel);
\& Function : apply a function to selected columns,
\&            then return the list of all return values
\& Returns  : list of all return values
\& Argument : $colf: Reference to the function that is applied to selected
\&            columns, its results are put into a list and returned.
\&            $rcolsel: Reference to the selector designating the columns
\&            to which colf is applied, as in cases (2)-(4) in seqs().
\&            $rrowsel: NOT used as a selector, but as a hint for
\&            determining the width of a sequence bag if $rcolsel is undef:
\&            The last index of the first row specified by $rrowsel is
\&            taken as the maximum column index.
.Ve
.Sh "\fIconsensus()\fR"
.IX Subsection "consensus()"
.Vb 12
\& Usage    : $cons_letters = $aln->consensus($threshold,$rcolsel);
\& Function : return the consensus of a (subset of) the columns; the letter '!'
\&            ($_NO_CONSENSUS_SYMBOL) indicates that no consensus letter exists
\& Returns  : in a scalar context: string of consensus letters
\&            in an array context: array of consensus letters
\& Argument : $threshold: A letter is considered consensus of a column
\&            if the fraction of the letters in the column that form a
\&            (relative) majority is >= $threshold. Ties between 2 letters with
\&            an equal relative majority are broken arbitrarily.
\&            The default value is 0.75.
\&            $rcolsel: Reference to the selector designating the columns
\&            of which the consensus is calculated, as in cases (2)-(4) in seqs().
.Ve
.Sh "\fIvar_sites()\fR"
.IX Subsection "var_sites()"
.Vb 14
\& Usage    : $resSlice = $aln->var_sites($threshold,$rrowsel);
\& Function : return the variable sites of an alignment
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $threshold: A column is considered variable
\&            if the fraction of the letters in the column that form a
\&            (relative) majority is NOT >= $threshold.
\&            The default $threshold is 1, i.e. only constant, INvariable columns
\&            are excluded.
\&            $rrowsel: Reference to the selector designating the rows
\&            of which in turn the letters in the variable columns are printed,
\&            as in cases (2)-(4) in seqs(). $rrowsel DOES NOT influence the
\&            calculation of the variable sites, it just constrains the output
\&            further !
.Ve
.Sh "\fIvar_inds()\fR"
.IX Subsection "var_inds()"
.Vb 12
\& Usage    : $indices = $aln->var_inds($threshold,$rrowsel);
\& Function : return the _indices_ of the variable sites of an alignment
\& Returns  : reference to array of indices
\& Argument : $threshold: A column is considered variable
\&            if the fraction of the letters in the column that form a
\&            (relative) majority is NOT >= $threshold.
\&            The default $threshold is 1, i.e. only constant, INvariable columns
\&            are excluded.
\&            $rrowsel: the first row in $rrowsel is used for
\&            determining the width of a sequence bag. In other words,
\&            the last index of the first row specified by $rrowsel is
\&            taken as the maximum column index.
.Ve
.Sh "\fIinvar_sites()\fR"
.IX Subsection "invar_sites()"
.Vb 9
\& Usage    : $resSlice = $aln->invar_sites($threshold,$rrowsel);
\& Function : return the INvariable columns of an alignment
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $threshold: A column is considered INvariable
\&            if the fraction of the letters in the column that form a
\&            (relative) majority is >= $threshold.
\&            The default $threshold is 1, i.e. no variability is allowed.
\&            $rrowsel: see var_sites()
.Ve
.Sh "\fIinvar_inds()\fR"
.IX Subsection "invar_inds()"
.Vb 2
\& Comment  : This is the indices-returning version of invar_sites(),
\&            cf. var_sites() and var_inds().
.Ve
.Sh "\fIgap_free_sites()\fR"
.IX Subsection "gap_free_sites()"
.Vb 5
\& Usage    : $resSlice = $aln->gap_free_sites($rrowsel);
\& Function : return the gap-free columns of an alignment.
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $rrowsel: see var_sites()
.Ve
.Sh "\fIgap_free_inds()\fR"
.IX Subsection "gap_free_inds()"
.Vb 2
\& Comment  : This is the indices-returning version of gap_free_sites(),
\&            cf. var_sites() and var_inds().
.Ve
.Sh "\fIunknown_free_sites()\fR"
.IX Subsection "unknown_free_sites()"
.Vb 5
\& Usage    : $resSlice = $aln->unknown_free_sites($rrowsel);
\& Function : return the unknown-free columns of an alignment.
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $rrowsel: see var_sites()
.Ve
.Sh "\fIunknown_free_inds()\fR"
.IX Subsection "unknown_free_inds()"
.Vb 2
\& Comment  : This is the indices-returning version of unknown_free_sites(),
\&            cf. var_sites() and var_inds().
.Ve
.Sh "\fIno_allgap_sites()\fR"
.IX Subsection "no_allgap_sites()"
.Vb 5
\& Usage    : $resSlice = $aln->no_allgap_sites($rrowsel);
\& Function : return the columns which do not have gaps only, of an alignment.
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $rrowsel: see var_sites()
.Ve
.Sh "\fIno_allgap_inds()\fR"
.IX Subsection "no_allgap_inds()"
.Vb 2
\& Comment  : This is the indices-returning version of no_allgap_sites(),
\&            cf. var_sites() and var_inds().
.Ve
.Sh "\fIspecial_free_sites()\fR"
.IX Subsection "special_free_sites()"
.Vb 6
\& Usage    : $resSlice = $aln->special_free_sites($rrowsel);
\& Function : return the special-free (neither gap nor unknown-symbols) columns
\&            of an alignment.
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $rrowsel: see var_sites()
.Ve
.Sh "\fIspecial_free_inds()\fR"
.IX Subsection "special_free_inds()"
.Vb 2
\& Comment  : This is the indices-returning version of special_free_sites(),
\&            cf. var_sites() and var_inds().
.Ve
.Sh "\fIreverse()\fR"
.IX Subsection "reverse()"
.Vb 6
\& Usage    : $resSlice = $aln->reverse($rrowsel);
\& Function : return the rows of an alignment, in reversed form (right->left)
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $rrowsel: Reference to the selector designating the rows
\&            which are returned in reversed form, as in cases (2)-(4) in seqs().
.Ve
.Sh "\fIremove_gaps()\fR"
.IX Subsection "remove_gaps()"
.Vb 7
\& Usage    : $resSlice = $aln->remove_gaps($rrowsel);
\& Function : return the rows of an alignment, gaps removed (i.e. the original
\&            sequences)
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $rrowsel: Reference to the selector designating the rows
\&            which are returned without gaps, as in cases (2)-(4) in seqs().
.Ve
.Sh "\fIcomplement()\fR"
.IX Subsection "complement()"
.Vb 8
\& Usage    : $resSlice = $aln->complement($rrowsel);
\& Function : return the rows of an alignment, in complemented form
\&            In the case of dna/rna, the complement is given according to the
\&            IUPAC code; in other cases the result is currently calculated in the
\&            same way and probably meaningless
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $rrowsel: see reverse()
.Ve
.Sh "\fIrevcom()\fR"
.IX Subsection "revcom()"
.Vb 8
\& Usage    : $aln->revcom($rrowsel);
\& Function : return the rows of an alignment, in reversed complement form
\&            In the case of dna/rna, the complement is given according to the
\&            IUPAC code; otherwise the result is currently calculated in the
\&            same way and probably nonsensical.
\& Returns  : in a scalar context: multiline string (including newline characters)
\&            in an array context: array of references to arrays of characters
\& Argument : $rrowsel: see reverse()
.Ve
.Sh "\fIequal_nogaps()\fR"
.IX Subsection "equal_nogaps()"
.Vb 5
\& Usage    : $aln->equal_nogaps($other_aln);
\& Function : checks whether two alignments have the same original sequences
\&            (i.e. gaps are removed and the rows are compared for equality)
\& Returns  : 1 if alignments are equal modulo gaps, 0 otherwise
\& Argument : $other_aln: the other alignment
.Ve
.Sh "\fIequalize_lengths()\fR"
.IX Subsection "equalize_lengths()"
.Vb 9
\& Usage    : $aln->equalize_lengths($width);
\& Function : modifies the alignment / sequence bag such that all rows
\&            have length $width; in the case of sequence bags, this
\&            is a primitive way to obtain a true alignment with
\&            rows of equal length
\&            * The current procedure is straightforward but slow *
\& Returns  : 1 if alignments are equal modulo gaps, 0 otherwise
\& Argument : $width: the length until which sequences should be padded;
\&            per default the length of the longest row is taken
.Ve
.Sh "\fI_seqs()\fR"
.IX Subsection "_seqs()"
.Vb 9
\& Usage    : @oldSeqs = $aln->_seqs(@sequences,$start)
\&            @oldSeqs = $aln->_seqs($sequences,$start)
\& Function : to APPEND/OVERWRITE sequences to an alignment
\& Returns  : old list of sequences, i.e. ($self->{'seqs'})
\& Argument : 1. EITHER a reference to a list of either Bio::Seq objects, or
\&               arrays of letters, or strings, or any mix of these,
\&               OR a single (multi-line) string
\&            2. $rrowsel: Reference to the selector designating the rows
\&               which shall be appended/overwritten (feature in alpha status)
.Ve
.Sh "\fIid()\fR"
.IX Subsection "id()"
.Vb 5
\& Usage    : $aln_id = $aln->id();
\&            $aln->id($id_string);
\& Function : Accessor, also sets field if an ID is passed in.
\& Returns  : (original) ID value
\& Argument : sequence string with no whitespace
.Ve
.Sh "\fIdesc()\fR"
.IX Subsection "desc()"
.Vb 5
\& Usage    : $aln_desc = $aln->desc();
\&            $aln->desc($desc_string);
\& Function : Accessor, also sets field if a description string is passed in.
\& Returns  : (original) description value
\& Argument : sequence string
.Ve
.Sh "\fInames()\fR"
.IX Subsection "names()"
.Vb 8
\& Usage    : %names = $aln->names;
\&            $aln->names($hash_ref)
\& Function : Accessor, also sets field if names hash is passed in.
\&            The names hash is 'human-readable' data; each key is a
\&            location (whether it be URL, database, database query, etc.)
\&            and each value is the id at that location.
\& Returns  : (original) names hash value
\& Argument : reference to a hash
.Ve
.Sh "\fIrow_ids()\fR"
.IX Subsection "row_ids()"
.Vb 5
\& Usage    : $row_ids = $aln->row_ids();
\&            $aln->row_ids($row_ids);
\& Function : Accessor, also sets field.
\& Returns  : A reference to the (original) array of row (sequence) ids
\& Argument : A reference to an array of row (sequence) ids
.Ve
.Sh "\fIcol_ids()\fR"
.IX Subsection "col_ids()"
.Vb 5
\& Usage    : $col_ids = $aln->col_ids();
\&            $aln->col_ids($col_ids);
\& Function : Accessor, also sets field.
\& Returns  : A reference to the (original) array of column (site) ids
\& Argument : A reference to an array of column (site) ids
.Ve
.Sh "\fIrow_descs()\fR"
.IX Subsection "row_descs()"
.Vb 5
\& Usage    : $row_descs = $aln->row_descs();
\&            $aln->row_descs($row_descs);
\& Function : Accessor, also sets field.
\& Returns  : A reference to the (original) array of row (sequence) descriptions
\& Argument : A reference to an array of row (sequence) descriptions
.Ve
.Sh "\fIcol_descs()\fR"
.IX Subsection "col_descs()"
.Vb 5
\& Usage    : $col_descs = $aln->col_descs();
\&            $aln->col_descs($col_descs);
\& Function : Accessor, also sets field.
\& Returns  : A reference to the (original) array of column (site) descriptions
\& Argument : A reference to an array of column (site) descriptions
.Ve
.Sh "\fInumbering()\fR"
.IX Subsection "numbering()"
.Vb 5
\& Usage    : $num_start = $aln->numbering;
\&            $aln->numbering($value);
\& Function : Accessor, also sets field if a new numbering scheme is passed in.
\& Returns  : (original) numbering value
\& Argument : number that is used as the offset of the first column
.Ve
.Sh "\fItype()\fR"
.IX Subsection "type()"
.Vb 7
\& Usage    : $aln_type = $aln->type;
\&            $aln->type($value); # May be dangerous !
\& Function : Accessor, also sets field if a new type is passed in.
\&            The latter is considered dangerous !
\& Returns  : (original) type value
\& Argument : new type, see the list %UnivAlnTypes in the code
\&            (currently, ``dna'', ``rna'', ``amino'')
.Ve
.Sh "\fIffmt()\fR"
.IX Subsection "ffmt()"
.Vb 9
\& Usage    : $ffmt = $aln->ffmt;
\&            $aln->ffmt($value);
\& Function : Accessor, also sets field if a new format acronym is passed in.
\&            This can be done before reading from a file, so that
\&            the presumably correct parsing routine is called, or
\&            the value can be set before writing the object using
\&            layout(), so that layout uses a specified default format.
\& Returns  : (original) format acronym
\& Argument : string describing the format, see ``Alignment Formats''
.Ve
.Sh "\fIinplace()\fR"
.IX Subsection "inplace()"
.Vb 11
\& Usage    : $inplace = $aln->inplace();
\&            $aln->inplace($value);
\& Function : Accessor, also sets field if a value is passed in.
\&            'inplace' is a flag which is set to true if accessors and
\&            functions should make the modification to the object itself,
\&            and just return true on success. Currently, inplace manipulation
\&            is supported for seqs(), _arys(), _strs(), remove_gaps(),
\&            var_sites(), invar_sites(), gap_free_sites(), no_allgap_sites(),
\&            reverse(), complement(), and revcom() (reverse complement).
\& Returns  : (original) inplace value
\& Argument : currently 0 or 1
.Ve
.Sh "\fIwidth()\fR"
.IX Subsection "width()"
.Vb 4
\& Usage    : $width = $aln->width();
\& Function : number of columns (of the first row per default)
\& Returns  : number of columns (of the first row per default)
\& Argument : row
.Ve
.Sh "\fIheight()\fR"
.IX Subsection "height()"
.Vb 4
\& Usage    : $height = $aln->height();
\& Function : number of rows (sequences)
\& Returns  : number of rows (sequences)
\& Argument : ./.
.Ve
.Sh "\fIalphabet_check()\fR"
.IX Subsection "alphabet_check()"
.Vb 12
\& Usage    : @offendig_characters = $aln->alphabet_check($rowsel);
\& Function : Check rows of the alignment for ``offending characters'', i.e.
\&            characters that are not (currently) expected to be found in the
\&            aligned sequences, because they're not in the default alphabet
\&            that belongs to the specified L<Alignment Type>.
\&            Currently, the Alignment Type can only be set explicitly
\&            via the constructor, or accessor. Since the default alphabet
\&            is not the IUPAC code (e.g. just A,C,G,T,-,? in case of DNA),
\&            this is just a proof of concept.
\& Returns  : an array containing the offending characters, one string per row
\& Argument : $rrowsel: Reference to the selector designating the rows
\&            to which the check is applied, as in cases (2)-(4) in seqs().
.Ve
.Sh "\fI_file_read()\fR"
.IX Subsection "_file_read()"
.Vb 5
\& Usage    : n/a (internal function)
\& Function : Read data from file, and call the parsing system to store data
\&            into the object fields
\& Returns  : 1 on success
\& Argument : filename, and (optionally) the format if known.
.Ve
.Sh "\fI_parse()\fR"
.IX Subsection "_parse()"
.Vb 9
\& Usage    : $aln->_parse($ent,[$ffmt]);
\& Function : Parses $ent into the object fields, according to
\&            $ffmt or $self->{'ffmt'}.
\& Returns  : 1 on success
\& Argument : the prospective alignment to be parsed,
\&            and optionally its format so that it doesn't need to be estimated
\&            Note that ``raw'' is not estimated in a reliable way by readseq
\&            if readseq is installed; I presume it is then estimated only if
\&            the sequence(s) are longer than 111 basepairs
.Ve
.Sh "\fI_parse_unknown()\fR"
.IX Subsection "_parse_unknown()"
.Vb 5
\& Usage    : $aln->_parse_unknown($ent);
\& Function : tries to figure out the format of $ent and then
\&            calls the appropriate function to parse it into $self->{'seqs'}.
\& Returns  : 1 on success
\& Argument : $ent : the rough multi-line string to be parsed
.Ve
.Sh "\fI_parse_bad()\fR"
.IX Subsection "_parse_bad()"
.Vb 4
\& Usage    : $aln->_parse_bad;
\& Function : Carp on the bad data that the user gave us.
\& Returns  : undef
\& Argument : (multiline) string that cannot be parsed
.Ve
.Sh "\fI_parse_readseq()\fR"
.IX Subsection "_parse_readseq()"
.Vb 4
\& Usage    : $aln->_parse_readseq;
\& Function : Try readseq to parse data.
\& Returns  : 1 on success
\& Argument : $ent : the rough multi-line string to be parsed
.Ve
.Sh "\fI_parse_raw()\fR"
.IX Subsection "_parse_raw()"
.Vb 5
\& Usage    : $aln->_parse_raw;
\& Function : parses $ent into the $self->{'seqs'} field, using raw
\&            file format.
\& Returns  : 1 on success
\& Argument : (multiline) string to be parsed
.Ve
.Sh "\fI_parse_fasta()\fR"
.IX Subsection "_parse_fasta()"
.Vb 5
\& Usage    : $aln->_parse_fasta;
\& Function : parses $ent into the 'seqs' field, using fasta
\&            file format.
\& Returns  : 1 on success
\& Argument : (multiline) string to be parsed
.Ve
.Sh "\fIcopy()\fR"
.IX Subsection "copy()"
.Vb 4
\& Usage    : $copyOfObj = $myUnivAln->copy;
\& Function : Returns an identical copy of the object.
\& Returns  : Bio::UnivAln
\& Argument : n/a
.Ve
.Sh "\fIlayout()\fR"
.IX Subsection "layout()"
.Vb 6
\& Usage    : $aln->layout($format);
\& Function : Returns the alignment in whichever format the user specifies,
\&            or according to the "ffmt" field if the user does not specify
\&            a format.
\& Returns  : varies; "" if unsuccessful
\& Argument : $format (one of the formats as defined in $UnivAlnForm).
.Ve
.Sh "\fIout_bad()\fR"
.IX Subsection "out_bad()"
.Vb 4
\& Usage    : $aln->out_bad;
\& Function : Carp if we don't know the output format.
\& Returns  : undef
\& Argument : n/a
.Ve
.Sh "\fIout_raw()\fR"
.IX Subsection "out_raw()"
.Vb 4
\& Usage    : $aln->out_raw;
\& Function : Returns the alignment in raw format.
\& Returns  : multiline string
\& Argument : n/a
.Ve
.Sh "\fIout_fasta()\fR"
.IX Subsection "out_fasta()"
.Vb 6
\& Usage    : $aln->out_fasta;
\& Function : Returns the alignment as a string in fasta format.
\& Returns  : multiline string
\& Argument : Same as seqs()
\& Comment  : The old ``out_fasta()'' function with no arguments
\&            is slightly faster and simpler; still available as out_fasta2().
.Ve
