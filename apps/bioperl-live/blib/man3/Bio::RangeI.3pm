.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:07 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::RangeI 3"
.TH Bio::RangeI 3 "perl v5.6.0" "2001-05-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::RangeI \- Range interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
None.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This provides a standard BioPerl range interface that should be
implemented by any object that wants to be treated as a range. This
serves purely as an abstract base class for implementers and can not
be instantiated.
.PP
Ranges are modeled as having (start, end, length, strand). They use
Bio-coordinates \- all points >= start and <= end are within the
range. End is always greater-than or equal-to start, and length is
greather than or equal to 1. The behaviour of a range is undefined if
ranges with negative numbers or zero are used.
.PP
So, in summary:
.PP
.Vb 3
\&  length = end - start + 1
\&  end >= start
\&  strand = (-1 | 0 | +1)
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org          - General discussion
\&  http://bio.perl.org/MailList.html             - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email:  heikki@ebi.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "Abstract methods"
.IX Header "Abstract methods"
These methods must be implemented in all subclasses.
.Sh "new"
.IX Subsection "new"
.Vb 5
\&  Title   : new
\&  Function: confesses if you try to instantiate a RangeI
\&          : RangeI is an interface, so RangeI->new should never be called
\&          : To make a range, instantiate one of the implementing classes. e.g.
\&          : $range = Bio::Range->new(-start=>20, -end=>2000, -strand=>1)
.Ve
.Sh "start"
.IX Subsection "start"
.Vb 6
\&  Title   : start
\&  Usage   : $start = $range->start();
\&  Function: get/set the start of this range
\&  Returns : the start of this range
\&  Args    : optionaly allows the start to be set
\&          : using $range->start($start)
.Ve
.Sh "end"
.IX Subsection "end"
.Vb 6
\&  Title   : end
\&  Usage   : $end = $range->end();
\&  Function: get/set the end of this range
\&  Returns : the end of this range
\&  Args    : optionaly allows the end to be set
\&          : using $range->end($end)
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 6
\&  Title   : length
\&  Usage   : $length = $range->length();
\&  Function: get/set the length of this range
\&  Returns : the length of this range
\&  Args    : optionaly allows the length to be set
\&          : using $range->length($length)
.Ve
.Sh "strand"
.IX Subsection "strand"
.Vb 6
\&  Title   : strand
\&  Usage   : $strand = $range->strand();
\&  Function: get/set the strand of this range
\&  Returns : the strandidness (-1, 0, +1)
\&  Args    : optionaly allows the strand to be set
\&          : using $range->strand($strand)
.Ve
.SH "Boolean Methods"
.IX Header "Boolean Methods"
These methods return true or false. They throw an error if start and end are
not defined.
.PP
.Vb 1
\& $range->overlaps($otherRange) && print "Ranges overlap\en";
.Ve
.Sh "overlaps"
.IX Subsection "overlaps"
.Vb 6
\&  Title   : overlaps
\&  Usage   : if($r1->overlaps($r2)) { do stuff }
\&  Function: tests if $r2 overlaps $r1
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&            arg #2 = strand option ('strong', 'weak', 'ignore') (optional)
\&  Returns : true if the ranges overlap, false otherwise
.Ve
.Sh "contains"
.IX Subsection "contains"
.Vb 7
\&  Title   : contains
\&  Usage   : if($r1->contains($r2) { do stuff }
\&  Function: tests whether $r1 totally contains $r2 
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&                     alternatively, integer scalar to test
\&            arg #2 = strand option ('strong', 'weak', 'ignore') (optional)
\&  Returns : true if the argument is totaly contained within this range
.Ve
.Sh "equals"
.IX Subsection "equals"
.Vb 5
\&  Title   : equals
\&  Usage   : if($r1->equals($r2))
\&  Function: test whether $r1 has the same start, end, length as $r2
\&  Args    : a range to test for equality
\&  Returns : true if they are describing the same range
.Ve
.SH "Geometrical methods"
.IX Header "Geometrical methods"
These methods do things to the geometry of ranges, and return
Bio::RangeI compliant objects or triplets (start, stop, strand) from
which new ranges could be built.
.Sh "intersection"
.IX Subsection "intersection"
.Vb 7
\&  Title   : intersection
\&  Usage   : ($start, $stop, $strand) = $r1->intersection($r2)
\&  Function: gives the range that is contained by both ranges
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&            arg #2 = strand option ('strong', 'weak', 'ignore') (optional)
\&  Returns : undef if they do not overlap, 
\&            or the range that they do overlap (in an objectlike the calling one)
.Ve
.Sh "union"
.IX Subsection "union"
.Vb 6
\&  Title   : union
\&  Usage   : ($start, $stop, $strand) = $r1->union($r2);
\&          : ($start, $stop, $strand) = Bio::RangeI->union(@ranges);
\&  Function: finds the minimal range that contains all of the ranges
\&  Args    : a range or list of ranges to find the union of
\&  Returns : the range object containing all of the ranges
.Ve
.Sh "overlap_extent"
.IX Subsection "overlap_extent"
.Vb 10
\& Title   : overlap_extent
\& Usage   : ($a_unique,$common,$b_unique) = $a->overlap_extent($b)
\& Function: Provides actual amount of overlap between two different
\&           ranges.
\& Example :
\& Returns : array of values for 
\&           - the amount unique to a
\&           - the amount common to both
\&           - the amount unique to b
\& Args    :
.Ve
