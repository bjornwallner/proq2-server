.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:36 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::LiveSeq::ChainI 3"
.TH Bio::LiveSeq::ChainI 3 "perl v5.6.0" "2001-06-19" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::LiveSeq::ChainI \- Double linked chain data structure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #documentation needed
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class generates and manipulates generic double linked list, chain,
that can be used to manage biological sequences.
.PP
The advantages over strings or plain arrays is the ease of tracking
changes (mutations) in the elements (sequence). The other side of the
coin is that these structures need consideraly more memory, but that
is cheap and constantly inceasing resource in computers.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org             - General discussion
\&  http://bio.perl.org/MailList.html - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \- Joseph A.L. Insana"
.IX Header "AUTHOR - Joseph A.L. Insana"
Email:  Insana@ebi.ac.uk, jinsana@gmx.net
Address: 
.PP
.Vb 3
\&     EMBL Outstation, European Bioinformatics Institute
\&     Wellcome Trust Genome Campus, Hinxton
\&     Cambs. CB10 1SD, United Kingdom
.Ve
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 11
\&  Title   : new
\&  Usage   : $chain = Bio::LiveSeq::ChainI->new(-string => "thequickbrownfoxjumpsoverthelazydog",
\&                                             -offset => 3 );
\&         OR $chain = Bio::LiveSeq::ChainI->new(-array => \e@array,
\&                                             -offset => 3 );
\&  Function: generates a new Bio::LiveSeq:ChainI
\&  Returns : a new Chain
\&  Args    : string
\&         OR arrayreference
\&        AND optional offset to create element labels
\&=cut
.Ve
sub new {
  my ($thing, \f(CW%args\fR) = \f(CW@_\fR;
  my \f(CW$class\fR = ref($thing) || \f(CW$thing\fR;
  my \f(CW$obj\fR;
.PP
.Vb 7
\&  if ($args{-string}) {
\&    $obj = $thing->string2chain($args{-string}, $args{-offset});
\&  } elsif ($args{-array}) {
\&    $obj = $thing->array2chain($args{-array}, $args{-offset});
\&  } else {
\&    croak "$class not initialized properly";
\&  }
.Ve
.Vb 3
\&  $obj = bless $obj, $class;
\&  return $obj;
\&}
.Ve
# added as of 1.9
sub string2chain {
  shift \f(CW@_\fR; # so that it doesn't pass the object reference
  return Bio::LiveSeq::Chain::string2chain(@_);
}
sub array2chain {
  shift \f(CW@_\fR; # so that it doesn't pass the object reference
  return Bio::LiveSeq::Chain::array2chain(@_);
}
#
sub chain2string {
  croak \*(L"ambiguous method call. Explicit down_ or up_\*(R";
}
sub down_chain2string {
  return Bio::LiveSeq::Chain::down_chain2string(@_);
}
sub up_chain2string {
  return Bio::LiveSeq::Chain::up_chain2string(@_);
}
sub chain2string_verbose {
  croak \*(L"ambiguous method call. Explicit down_ or up_\*(R";
}
sub down_chain2string_verbose {
  return Bio::LiveSeq::Chain::down_chain2string_verbose(@_);
}
sub up_chain2string_verbose {
  return Bio::LiveSeq::Chain::up_chain2string_verbose(@_);
}
sub invert_chain {
  return Bio::LiveSeq::Chain::invert_chain(@_);
}
sub mutate_element {
  croak \*(L"Old method name, please update code to: set_value_at_label\*(R";
}
.PP
# new as of version 2.33 of Chain.pm
sub down_labels {
  return Bio::LiveSeq::Chain::down_labels(@_);
}
sub up_labels {
  return Bio::LiveSeq::Chain::up_labels(@_);
}
.PP
sub start {
  return Bio::LiveSeq::Chain::start(@_);
}
sub end {
  return Bio::LiveSeq::Chain::end(@_);
}
sub label_exists {
  return Bio::LiveSeq::Chain::label_exists(@_);
}
.PP
sub get_value_at_pos {
  croak \*(L"ambiguous method call. Explicit down_ or up_\*(R";
}
sub down_get_value_at_pos {
  return Bio::LiveSeq::Chain::down_get_value_at_pos(@_);
}
sub up_get_value_at_pos {
  return Bio::LiveSeq::Chain::up_get_value_at_pos(@_);
}
sub set_value_at_pos {
  croak \*(L"ambiguous method call. Explicit down_ or up_\*(R";
}
sub down_set_value_at_pos {
  return Bio::LiveSeq::Chain::down_set_value_at_pos(@_);
}
sub up_set_value_at_pos {
  return Bio::LiveSeq::Chain::up_set_value_at_pos(@_);
}
sub get_value_at_label {
  return Bio::LiveSeq::Chain::get_value_at_label(@_);
}
sub set_value_at_label {
  return Bio::LiveSeq::Chain::set_value_at_label(@_);
}
sub get_label_at_pos {
  croak \*(L"ambiguous method call. Explicit down_ or up_\*(R";
}
sub up_get_label_at_pos {
  return Bio::LiveSeq::Chain::up_get_label_at_pos(@_);
}
sub down_get_label_at_pos {
  return Bio::LiveSeq::Chain::down_get_label_at_pos(@_);
}
sub get_pos_of_label {
  croak \*(L"ambiguous method call. Explicit down_ or up_\*(R";
}
sub up_get_pos_of_label {
  return Bio::LiveSeq::Chain::up_get_pos_of_label(@_);
}
sub down_get_pos_of_label {
  return Bio::LiveSeq::Chain::down_get_pos_of_label(@_);
}
#
.PP
sub preinsert_string {
  return Bio::LiveSeq::Chain::praeinsert_string(@_);
}
sub preinsert_array {
  return Bio::LiveSeq::Chain::praeinsert_array(@_);
}
sub praeinsert_string {
  return Bio::LiveSeq::Chain::praeinsert_string(@_);
}
sub postinsert_string {
  return Bio::LiveSeq::Chain::postinsert_string(@_);
}
sub praeinsert_array {
  return Bio::LiveSeq::Chain::praeinsert_array(@_);
}
sub postinsert_array {
  return Bio::LiveSeq::Chain::postinsert_array(@_);
}
sub down_element{
  return Bio::LiveSeq::Chain::down_element(@_);
}
sub up_element {
  return Bio::LiveSeq::Chain::up_element(@_);
}
sub is_downstream {
  return Bio::LiveSeq::Chain::is_downstream(@_);
}
sub is_upstream {
  return Bio::LiveSeq::Chain::is_upstream(@_);
}
sub check_chain {
  return Bio::LiveSeq::Chain::check_chain(@_);
}
sub chain_length {
  return Bio::LiveSeq::Chain::chain_length(@_);
}
sub splice_chain {
  return Bio::LiveSeq::Chain::splice_chain(@_);
}
sub pos_of_element {
  croak \*(L"ambiguous and old method name. use: down_pos_of_label\*(R";
}
sub up_pos_of_element {
  croak \*(L"old method name. use: down_pos_of_label\*(R";
  return Bio::LiveSeq::Chain::up_pos_of_element(@_);
}
sub down_pos_of_element {
  croak \*(L"old method name. use: up_pos_of_label\*(R";
  return Bio::LiveSeq::Chain::down_pos_of_element(@_);
}
sub subchain_length {
  croak \*(L"ambiguous method call. Explicit down_ or up_\*(R";
}
sub down_subchain_length {
  return Bio::LiveSeq::Chain::down_subchain_length(@_);
}
sub up_subchain_length {
  return Bio::LiveSeq::Chain::up_subchain_length(@_);
}
.PP
# these have to be deleted and changed names to conform to terminology
sub elements {
  return Bio::LiveSeq::Chain::down_elements(@_);
}
sub up_elements {
  return Bio::LiveSeq::Chain::up_elements(@_);
}
sub down_elements {
  return Bio::LiveSeq::Chain::down_elements(@_);
}
.PP
1;
