.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:39 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "BIODESIGN 1"
.TH BIODESIGN 1 "perl v5.6.0" "2001-05-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bioperl \- Design Documentation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Not appropiate. Read on...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bioperl is a coordinated project which has a number of design features
to allow bioperl to be well used, extended and collaborate with other
packages. This design can be focused in a number of areas.
.PP
.Vb 4
\&  bioperl ettiquette and learning about it
\&  bioperl root object - exception throwing, exceptions etc.
\&  bioperl interface design
\&  bioperl sequence object design notes
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
This was written by Ewan Birney in a variety of airports across the \s-1US\s0.
.SH "Reusing code and working in collaborative projects"
.IX Header "Reusing code and working in collaborative projects"
The biggest problem often in reusing a code base like bioperl is that
it requires both the people using it and the people contributing to
it to change their attitude towards code. Generally people in bioinformatics
are more likely to be self-taught, single programmers, who put together most
of their scripts/programs as individuals. Bioperl is a truely collaborative
project (the core code is the product of about 15 individuals) and anyone
will be only contributing some part of it in the future.
.PP
Here are some notes about how my coding style has changed to work in
collaborative projects.
.Sh "Learn to read documentation"
.IX Subsection "Learn to read documentation"
Reading documentation is sometimes as tough as writing the
documentation. Try to read documentation before you ask a question \-
not only might it answer your question, but more importantly it will
give you idea why the person who wrote the module wrote it \- and this
will be the frame work in which you can understand his or her answer.
.Sh "Respect people's code (in particular if it works)"
.IX Subsection "Respect people's code (in particular if it works)"
If the code does what you want, the fact that it is not written the
way you would write should not be a big issue. Of course, if there is
some glaring error then that is worth pointing out to
someone. Dismissing a module on the basis of its coding style is a
tremendously wrong thing to do.
.Sh "Learn how to provide good feedback"
.IX Subsection "Learn how to provide good feedback"
This ranges from giving very accurate bug reports (this script \-->
makes this error, giving all data), through to pointing out design
issues in a constructive manner (not \- this *sucks*). If you find
a problem, then providing a patch using diff or work around is
a great thing to do \- the author/maintainer of the module will
love you for it.
.PP
Providing \*(L"I used \s-1XXX\s0 and it did just what I wanted it to do\*(R" feedback
is also really great. Developers generally only hear about their mistakes.
To hear about successes gives everyone a warm glow.
.PP
One trick I have learnt is that when I download a new project/code or
use a new module I open up a fresh buffer in emacs and keep a mini diary
of everything that I did or think when I started to use the package. After
I used it I could go back, edit the buffer and then send it to the author
either with \*(L"it was great \- it did just what I wanted, but I found that
the documentation here was misleading\*(R" to \*(L"to get it to install I had
to incant the following things...\*(R"
.Sh "Taking on a project"
.IX Subsection "Taking on a project"
When you want to get involved, hopefully it will be because you want to
extend something or provide better facillities to something. The important
thing here is not to work in a vacuum. By providing the main list with
a good proposal before you start about what you are going to do (and listen
to the responses) is a must. I have been pulled up so many times by other
people looking at my design that I can't imagine coding stuff now without
feedback.
.Sh "Designing good tests"
.IX Subsection "Designing good tests"
Sadly, you might think that you have written good code, but you don't know
that until you manage to test it! The \s-1CPAN\s0 style perl modules have a wonderful
test suite system (delve around into the t/ directories) and I have extended
the makefile system so that the test script which you write to test the module
can be part of the t/ system from the start. Once a test is in the t/ system it
will be run millions of times worldwide when bioperl is downloaded, providing
incredible and continual regression testing of your module (for free!).
.Sh "Having fun"
.IX Subsection "Having fun"
The coding process should be enjoyable, and I get very proud of people who tell
me that they picked up bioperl and it worked for them, even if they don't use
a single module that I wrote. There is a brilliant sense of community in bioperl
about providing useful, stable code and it should be a pleasure to contribute to it.
.PP
So \- I am always looking forward to people posting on the guts list
with their feedback/questions/proposals. As well as the long standing fun we
have making new releases.
.SH "Bioperl Root Object"
.IX Header "Bioperl Root Object"
All objects in bioperl (but for interfaces \- see the next section) inheriet
from the Root Object. The bioperl root object allows a number of very useful
concepts to be provided. In particular.
.Ip "exceptions" 3
.IX Item "exceptions"
.Vb 2
\&   Bioperl root object allow exceptions to be throw on the object with very
\&nice debugging output
.Ve
.Ip "context" 3
.IX Item "context"
.Vb 2
\&   Bioperl root object have a context which allows, in particular, exceptions
\&that are thrown to say which object as throwing the exception.
.Ve
.Ip "rearrange" 3
.IX Item "rearrange"
.Vb 2
\&   Bioperl root object have some helper methods, in particular rearrange to
\&help functions which take hash inputs.
.Ve
.Sh "Using the root object."
.IX Subsection "Using the root object."
To use the root object, the object has to inheriet from it. This means
the \f(CW@ISA\fR array should have (Bio::Roo::Object) in it and that the
module goes \*(L"use Bio::Root::Object\*(R". The root object provides the
->new function. This new function builds a hash, sets some root object
management issues and then calls the _initialize function. It is this
function which your object needs to implement.  The full code is given
below.
.PP
.Vb 2
\&   # convention is that if you are using the Bio::Root object you should put it
\&   # inside the Bio namespace
.Ve
.Vb 3
\&   package Bio::MyNewObject;
\&   use vars qw(@ISA);
\&   use strict;
.Ve
.Vb 2
\&   use Bio::Root::Object;
\&   @ISA = qw(Bio::Root::Object);
.Ve
.Vb 2
\&   # new() is inherited from Bio::Root::Object
\&   # _initialize is where the heavy stuff will happen when new is called
.Ve
.Vb 3
\&  sub _initialize {
\&     my($self,@args) = @_;
\&     # call superclasses initialize
.Ve
.Vb 1
\&     my $make = $self->SUPER::_initialize(@args);
.Ve
.Vb 2
\&     # do your own argument processing here
\&     # set default attributes etc...
.Ve
.Vb 2
\&     return $make; # success - we hope!
\&  }
.Ve
.Sh "Throwing Exceptions"
.IX Subsection "Throwing Exceptions"
.Vb 6
\& Exceptions are die functions, in which the $@ variable (a scalar) is
\&used to indicate how it died. The exceptions can be caught using the
\&eval {} system. The bioperl root object has a method called "-E<gt>throw"
\&which calls die but also provides a full stack trace of where this
\&throw happened on (and also which object the exception was thrown -
\&see the context section). So an exception like
.Ve
.Vb 1
\&  $obj->throw("I am throwing an exception");
.Ve
Provides the following output on \s-1STDERR\s0 if is not caught.
.PP
.Vb 8
\&  -------------------- EXCEPTION --------------------
\&  MSG: I am throwing an exception
\&  CONTEXT: Error in object Bio::Root::Object "anonymous Bio::Root::Object"
\&  SCRIPT: myscript.pl
\&  STACK:
\&  main::my_subroutine(7)
\&  main::(3)
\&  ---------------------------------------------------
.Ve
indicating that this exception was thrown at line 7 of subroutine my_subroutine,
in myscript.pl
.PP
Exceptions can be caught using an eval block, such as
.PP
.Vb 6
\& my $obj = Bio::SomeObject->new();
\& my $obj2
\& eval {
\&   $obj2 = $obj->method1();
\&   $obj2->method2(10);
\& }
.Ve
.Vb 5
\& if( $@ ) {
\&   # exception was thrown
\&   &tell_user("Exception was thrown, preventing whatever I wanted to do. Actual exception $@");
\&   exit(0);
\& }
.Ve
.Vb 1
\& # else - use $obj2
.Ve
notice that the eval block can have multiple statements in it, and
also that if you want to use variables outside of the eval block, they
must be declared with my outside of the eval block (you are planning
to use strict in your scripts, aren't you!).
.Sh "object context"
.IX Subsection "object context"
Each bioperl object has a context, which is given by the name
attribute (name is a method defined in the Bio::Root::Object
package). This context is displayed when the exception is made, so
that the following script:
.PP
.Vb 2
\&  use Bio::Root::Object;
\&  $obj = Bio::Root::Object->new;
.Ve
.Vb 2
\&  $obj->name("Context-A");
\&  &my_subroutine($obj);
.Ve
.Vb 4
\&  sub my_subroutine {
\&        $self = shift;
\&        $self->throw("I am throwing an exception");
\&  }
.Ve
Produces the following exception
.PP
.Vb 8
\&  -------------------- EXCEPTION --------------------
\&  MSG: I am throwing an exception
\&  CONTEXT: Error in object Bio::Root::Object "Context-A"
\&  SCRIPT: test2.pl
\&  STACK:
\&  main::my_subroutine(10)
\&  main::test2.pl(6)
\&  ---------------------------------------------------
.Ve
Notice that the Object nows says that it is Context-A.
.PP
This context is particularly useful when objects are produced from a
database. This is because some exceptions are really due to problems
with the data in an object rather than the code. These sort of
exceptions are better tracked down when you know where the object came
from, not where in the code the exception is thrown.
.PP
One of the drawbacks to this scheme is that the attribute ->name is
\&\*(L"special\*(R" from bioperl's perspective. I believe it is best to stay
away from using \f(CW$obj\fR->\fIname()\fR to mean anything from the object's
perspective (for example ->\fIid()\fR ), leaving it free to be used as a
context for debugging purposes. You might prefer to overload the name
attribute to be \*(L"useful\*(R" for the object.
.SH "Bioperl Interface design"
.IX Header "Bioperl Interface design"
Bioperl has been moving to a split between \fBinterface\fR and
\&\fBimplementation\fR definitions.  An interface is solely the definition
of what methods one can call on an object, without any knowledge of
how it is implemented. An implementation is an actual, working
implementation of an object. In languages like Java, interface
definition is part of the language. In Perl, like many aspects of Perl
you have to roll your own.
.PP
In bioperl, the interface names are called Bio::MyObjectI, with the
trailing I indicating it is an interface definition of an object. The
interface files (sometimes nicknamed the 'I files') provide mainly
documentation on what the interface is, and how to use (and implement
it). All the functions which the implementation is expected to provide
are defined as subroutines, and then die with an informative
warning. The exception to this rule are the implementation independent
functions (see later).
.PP
Objects which want to implement this interface should inheriet the
Bio::MyObjectI file in their \f(CW@ISA\fR array. This means that if the
implementation does not provide a method which the interface defines,
rather than the user getting a \*(L"method not found error\*(R" it gets a
\&\*(L"mymethod was not defined in MyObjectI, but should have been\*(R" which
makes it clearer that whoever provided the implementation was to
blame, and not the caller/script writer.
.PP
When people want to check they have valid objects being passed to
their functions they should test the presence of the interface, not
the implementation. for example
.PP
.Vb 2
\&  sub my_sequence_routine {
\&    my($seq,$other_argument) = @_;
.Ve
.Vb 1
\&    $seq->isa('Bio::SeqI') || die "[$seq] is not a sequence. Cannot process";
.Ve
.Vb 1
\&    # do stuff
.Ve
.Vb 1
\&  }
.Ve
This is in contrast to
.PP
.Vb 2
\&  sub my_incorrect_sequence_routine {
\&    my($seq,$other_argument) = @_;
.Ve
.Vb 2
\&    # this line is INCORRECT
\&    $seq->isa('Bio::Seq') || die "[$seq] is not a sequence. Cannot process";
.Ve
.Vb 1
\&    # do stuff
.Ve
.Vb 1
\&  }
.Ve
.Sh "Rationale of interface design"
.IX Subsection "Rationale of interface design"
Some people might justifiably argue \*(L"why do this?\*(R". The main reason is
to support external objects from bioperl, and allow them to masquarade
as real bioperl objects. For example you might have your own quite
intricate sequence object which you want to use in bioperl functions,
but don't want to lose your own neat coding. One option would be to
have a function which built a bioperl sequence object from your
object, but then you would be endlessly building temporary objects and
destroying them, in particular if the script yo-yoed between your code
and bioperl code.
.PP
A better solution would be to implement the Bio::SeqI interface. You
would read the Bio::SeqI documentation, and then provide the methods
which it required, and put Bio::SeqI in your \f(CW@ISA\fR array. Then you
could pass in your object into bioperl routines and eh voila \- you
\&\fBare\fR a bioperl sequence object.
.PP
(A problem might arise if your object has the same methods as the
Bio::SeqI methods but use them differently \- your \f(CW$obj\fR->\fIid()\fR might
mean provide the raw memory location of the object, whereas the
documentation for Bio::SeqI \f(CW$obj\fR->\fIid()\fR says it should return the
human-readable name. If so you need to look into providing an
\&'Adaptor' class, as suggested in the Gang-of-four).
.PP
Interface classes really come into their own when we start leaving
Perl and enter extensions wrapped over C or over databases, or
through systems like \s-1CORBA\s0 to other languages, like Java/Python
etc. Here the \*(L"object\*(R" is often a very thin wrapper over the
a \s-1DBI\s0 interface, or an \s-1XS\s0 interface, and how it stores the object
is really different. By providing a very clear, implementation free
interface with good documentation there is a very clear target
to hit.
.PP
Some people might complain that we are doing something very \*(L"un-perl-like\*(R"
by providing these separate interface files. They are 90% documentation,
and could be provided anywhere, in many ways they could be merged with
the actual implementation classes and just made clear that if someone
wants to mimic a class they should override the following methods. However,
we (and in particular myself \- Ewan) prefers a clear separation of the
interface. It gives us a much clearer way of defining what is going on.
It is in many ways just \*(L"design sugar\*(R" (as opposed to syntactic sugar)
to help us, but it really helps, so thats good enough justification to me.
.Sh "Implementation functions in Interface files"
.IX Subsection "Implementation functions in Interface files"
One of the issues we discovered early on in using Interface files was
that there were methods that we would like to provide for classes
which were independent of their implementation. A good example is
a \*(L"Range\*(R" interface, which might define the following methods
.PP
.Vb 2
\&   $obj->start()
\&   $obj->end()
.Ve
Now a client to the object might want to use a \f(CW$obj\fR->\fIlength()\fR method.
because it is much easier than retrieving the two attributes and
substracting them. However, the ->\fIlength()\fR method is just a pain for
someone providing the implementation to provide \- once \fIstart()\fR and
\&\fIend()\fR is defined, length is. There seems to be a catch-22 here: to
make an object definition good for a \fBclient\fR one needs to have
additional, helper methods \*(L"on top of\*(R" the interface, however to make
life easier for the \fBobject implementation\fR one wants to have the
bare minimum of functions defined which the implementer has to
provide.
.PP
In the Range interface this became more than annoyance, as alot of the
\&\*(L"smarts\*(R" of the Range system was that we wanted to have the ability to
say
.PP
.Vb 1
\&  if( $range->intersection($someother_range) )
.Ve
We wanted a generic RangeI interface that we could apply to many
objects, with definitions required only for ->start, ->end and
->strand. However we wanted the ->intersection, and
->union methods to be on all ranges, without us having to
reimplement this every time.
.PP
Our (Matt Pocock and Ewan Birney's) solution was to allow
implementation into the RangeI interface file, but only when these
implementations sat \*(L"on top\*(R" of the interface definition and therefore
provided helper client operations. In a language like Java, we would
clearly have two classes, with a composition/delegation method:
.PP
.Vb 1
\&   MyPublicSomethingClass has-a MyInternalSomethingInterface, with
.Ve
.Vb 1
\&   ADifferentImplemtation implements MyInternalSomethingInterface
.Ve
However this is really heavy handed in Perl (and people were
complaining about having different implementation/interface
classes). We were quite happy about merging the implementation
independent functions with the interface definition, and I (Ewan) used
this in other interfaces since then. The documentation has to be clear
about what is going on, but I think in general it is.
.Sh "\s-1IDL\s0 (Interface Definition Language)"
.IX Subsection "IDL (Interface Definition Language)"
There is an idl definition of bioperl in bioperl.idl. This is the start
of a new era of interoperability in this field, so please read it and
see if you can comment on it.
