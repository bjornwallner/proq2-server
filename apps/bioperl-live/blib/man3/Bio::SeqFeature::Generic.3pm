.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:01 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::SeqFeature::Generic 3"
.TH Bio::SeqFeature::Generic 3 "perl v5.6.0" "2001-06-12" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::SeqFeature::Generic \- Generic SeqFeature
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&   $feat = new Bio::SeqFeature::Generic ( -start => 10, -end => 100,
\&                                -strand => -1, -primary => 'repeat',
\&                                -source => 'repeatmasker',
\&                                -score  => 1000,
\&                                -tag    => {
\&                                    new => 1,
\&                                    author => 'someone',
\&                                    sillytag => 'this is silly!' } );
.Ve
.Vb 3
\&   $feat = new Bio::SeqFeature::Generic ( -gff_string => $string );
\&   # if you want explicitly GFF1
\&   $feat = new Bio::SeqFeature::Generic ( -gff1_string => $string );
.Ve
.Vb 1
\&   # add it to an annotated sequence
.Ve
.Vb 1
\&   $annseq->add_SeqFeature($feat);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::SeqFeature::Generic is a generic implementation for the
Bio::SeqFeatureI interface, providing a simple object to provide all
the information for a feature on a sequence.
.PP
For many Features, this is all you will need to use (for example, this
is fine for Repeats in \s-1DNA\s0 sequence or Domains in protein
sequence). For other features, which have more structure, this is a
good base class to extend using inheritence to have new things: this
is what is done in the Bio::SeqFeature::Gene,
Bio::SeqFeature::Transcript and Bio::SeqFeature::Exon, which provide
well coordinated classes to represent genes on \s-1DNA\s0 sequence (for
example, you can get the protein sequence out from a transcript
class).
.PP
For many Features, you want to add some piece of information, for
example a common one is that this feature is 'new' whereas other
features are 'old'.  The tag system, which here is implemented using a
hash can be used here.  You can use the tag system to extend the
SeqFeature::Generic programmatically: that is, you know that you have
read in more information into the tag 'mytag' which you can the
retrieve. This means you do not need to know how to write inherieted
Perl to provide more complex information on a feature, and/or, if you
do know but you donot want to write a new class every time you need
some extra piece of information, you can use the tag system to easily
store and then retrieve information.
.PP
The tag system can be written in/out of \s-1GFF\s0 format, and also into \s-1EMBL\s0
format via AnnSeqIO::EMBL.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org          - General discussion
\&  http://bio.perl.org/MailList.html             - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Ewan Birney <birney@sanger.ac.uk>
.SH "DEVELOPERS"
.IX Header "DEVELOPERS"
This class has been written with an eye out of inheritence. The fields
the actual object hash are:
.PP
.Vb 5
\&   _gsf_tag_hash  = reference to a hash for the tags
\&   _gsf_sub_array = reference to an array for sub arrays
\&   _gsf_start     = scalar of the start point
\&   _gsf_end       = scalar of the end point
\&   _gsf_strand    = scalar of the strand
.Ve
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "location"
.IX Subsection "location"
.Vb 6
\& Title   : location
\& Usage   : my $location = $seqfeature->location()
\& Function: returns a location object suitable for identifying location 
\&           of feature on sequence or parent feature  
\& Returns : Bio::LocationI object
\& Args    : none
.Ve
.Sh "start"
.IX Subsection "start"
.Vb 6
\& Title   : start
\& Usage   : $start = $feat->start
\&           $feat->start(20)
\& Function: Get/set on the start coordinate of the feature
\& Returns : integer
\& Args    : none
.Ve
.Sh "end"
.IX Subsection "end"
.Vb 6
\& Title   : end
\& Usage   : $end = $feat->end
\&           $feat->end($end)
\& Function: get/set on the end coordinate of the feature
\& Returns : integer
\& Args    : none
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 6
\& Title   : length
\& Usage   :
\& Function:
\& Example :
\& Returns :
\& Args    :
.Ve
.Sh "strand"
.IX Subsection "strand"
.Vb 6
\& Title   : strand
\& Usage   : $strand = $feat->strand()
\&           $feat->strand($strand)
\& Function: get/set on strand information, being 1,-1 or 0
\& Returns : -1,1 or 0
\& Args    : none
.Ve
.Sh "score"
.IX Subsection "score"
.Vb 6
\& Title   : score
\& Usage   : $score = $feat->score()
\&           $feat->score($score)
\& Function: get/set on score information
\& Returns : float
\& Args    : none if get, the new value if set
.Ve
.Sh "frame"
.IX Subsection "frame"
.Vb 6
\& Title   : frame
\& Usage   : $frame = $feat->frame()
\&           $feat->frame($frame)
\& Function: get/set on frame information
\& Returns : 0,1,2, '.'
\& Args    : none if get, the new value if set
.Ve
.Sh "sub_SeqFeature"
.IX Subsection "sub_SeqFeature"
.Vb 5
\& Title   : sub_SeqFeature
\& Usage   : @feats = $feat->sub_SeqFeature();
\& Function: Returns an array of sub Sequence Features
\& Returns : An array
\& Args    : none
.Ve
.Sh "add_sub_SeqFeature"
.IX Subsection "add_sub_SeqFeature"
.Vb 7
\& Title   : add_sub_SeqFeature
\& Usage   : $feat->add_sub_SeqFeature($subfeat);
\&           $feat->add_sub_SeqFeature($subfeat,'EXPAND')
\& Function: adds a SeqFeature into the subSeqFeature array.
\&           with no 'EXPAND' qualifer, subfeat will be tested
\&           as to whether it lies inside the parent, and throw
\&           an exception if not.
.Ve
.Vb 5
\&           If EXPAND is used, the parent's start/end/strand will
\&           be adjusted so that it grows to accommodate the new
\&           subFeature
\& Returns : nothing
\& Args    : An object which has the SeqFeatureI interface
.Ve
.Sh "flush_sub_SeqFeature"
.IX Subsection "flush_sub_SeqFeature"
.Vb 9
\& Title   : flush_sub_SeqFeature
\& Usage   : $sf->flush_sub_SeqFeature
\& Function: Removes all sub SeqFeature
\&           (if you want to remove only a subset, take
\&            an array of them all, flush them, and add
\&            back only the guys you want)
\& Example :
\& Returns : none
\& Args    : none
.Ve
.Sh "primary_tag"
.IX Subsection "primary_tag"
.Vb 7
\& Title   : primary_tag
\& Usage   : $tag = $feat->primary_tag()
\&           $feat->primary_tag('exon')
\& Function: get/set on the primary tag for a feature,
\&           eg 'exon'
\& Returns : a string
\& Args    : none
.Ve
.Sh "source_tag"
.IX Subsection "source_tag"
.Vb 7
\& Title   : source_tag
\& Usage   : $tag = $feat->source_tag()
\&           $feat->source_tag('genscan');
\& Function: Returns the source tag for a feature,
\&           eg, 'genscan'
\& Returns : a string
\& Args    : none
.Ve
.Sh "has_tag"
.IX Subsection "has_tag"
.Vb 6
\& Title   : has_tag
\& Usage   : $value = $self->has_tag('some_tag')
\& Function: Tests wether a feature contaings a tag
\& Returns : TRUE if the SeqFeature has the tag,
\&           and FALSE otherwise.
\& Args    : The name of a tag
.Ve
.Sh "add_tag_value"
.IX Subsection "add_tag_value"
.Vb 4
\& Title   : add_tag_value
\& Usage   : $self->add_tag_value('note',"this is a note");
\& Returns : TRUE on success
\& Args    : tag (string) and value (any scalar)
.Ve
.Sh "each_tag_value"
.IX Subsection "each_tag_value"
.Vb 6
\& Title   : each_tag_value
\& Usage   : @values = $gsf->each_tag_value('note');
\& Function: Returns a list of all the values stored
\&           under a particular tag.
\& Returns : A list of scalars
\& Args    : The name of the tag
.Ve
.Sh "all_tags"
.IX Subsection "all_tags"
.Vb 5
\& Title   : all_tags
\& Usage   : @tags = $feat->all_tags()
\& Function: Get a list of all the tags in a feature
\& Returns : An array of tag names
\& Args    : none
.Ve
.Sh "remove_tag"
.IX Subsection "remove_tag"
.Vb 5
\& Title   : remove_tag
\& Usage   : $feat->remove_tag('some_tag')
\& Function: removes a tag from this feature
\& Returns : nothing
\& Args    : tag (string)
.Ve
.Sh "attach_seq"
.IX Subsection "attach_seq"
.Vb 8
\& Title   : attach_seq
\& Usage   : $sf->attach_seq($seq)
\& Function: Attaches a Bio::Seq object to this feature. This
\&           Bio::Seq object is for the *entire* sequence: ie
\&           from 1 to 10000
\& Example :
\& Returns : TRUE on success
\& Args    :
.Ve
.Sh "seq"
.IX Subsection "seq"
.Vb 6
\& Title   : seq
\& Usage   : $tseq = $sf->seq()
\& Function: returns the truncated sequence (if there) for this
\& Example :
\& Returns : sub seq on attached sequence bounded by start & end
\& Args    : none
.Ve
.Sh "entire_seq"
.IX Subsection "entire_seq"
.Vb 6
\& Title   : entire_seq
\& Usage   : $whole_seq = $sf->entire_seq()
\& Function: gives the entire sequence that this seqfeature is attached to
\& Example :
\& Returns :
\& Args    :
.Ve
.Sh "seqname"
.IX Subsection "seqname"
.Vb 6
\& Title   : seqname
\& Usage   : $obj->seqname($newval)
\& Function: There are many cases when you make a feature that you
\&           do know the sequence name, but do not know its actual
\&           sequence. This is an attribute such that you can store
\&           the seqname.
.Ve
.Vb 5
\&           This attribute should *not* be used in GFF dumping, as
\&           that should come from the collection in which the seq
\&           feature was found.
\& Returns : value of seqname
\& Args    : newvalue (optional)
.Ve
.Sh "annotation"
.IX Subsection "annotation"
.Vb 6
\& Title   : annotation
\& Usage   : $obj->annotation($annot_obj)
\& Function: 
\& Example : 
\& Returns : A Bio::Annotation object
\& Args    : newvalue (optional)
.Ve
.Sh "gff_format"
.IX Subsection "gff_format"
.Vb 7
\& Title   : gff_format
\& Usage   : # get:
\&           $gffio = $feature->gff_format();
\&           # set (change the default version of GFF2):
\&           $feature->gff_format(Bio::Tools::GFF->new(-gff_version => 1));
\& Function: Get/set the GFF format interpreter. This object is supposed to 
\&           format and parse GFF. See Bio::Tools::GFF for the interface.
.Ve
.Vb 6
\&           If this method is called as class method, the default for all
\&           newly created instances will be changed. Otherwise only this
\&           instance will be affected.
\& Example : 
\& Returns : a Bio::Tools::GFF compliant object
\& Args    : On set, an instance of Bio::Tools::GFF or a derived object.
.Ve
.Sh "gff_string"
.IX Subsection "gff_string"
.Vb 4
\& Title   : gff_string
\& Usage   : $str = $feat->gff_string;
\&           $str = $feat->gff_string($gff_formatter);
\& Function: Provides the feature information in GFF format.
.Ve
.Vb 2
\&           We override this here from Bio::SeqFeatureI in order to use the
\&           formatter returned by gff_format().
.Ve
.Vb 2
\& Returns : A string
\& Args    : Optionally, an object implementing gff_string().
.Ve
.Sh "_from_gff_string"
.IX Subsection "_from_gff_string"
.Vb 3
\& Title   : _from_gff_string
\& Usage   :
\& Function: Set feature properties from GFF string.
.Ve
.Vb 7
\&           This method uses the object returned by gff_format() for the
\&           actual interpretation of the string. Set a different GFF format
\&           interpreter first if you need a specific version, like GFF1. (The
\&           default is GFF2.)
\& Example :
\& Returns : 
\& Args    : a GFF-formatted string
.Ve
.Sh "_expand_region"
.IX Subsection "_expand_region"
.Vb 4
\& Title   : _expand_region
\& Usage   : $self->_expand_region($feature);
\& Function: Expand the total region covered by this feature to
\&           accomodate for the given feature.
.Ve
.Vb 4
\&           May be called whenever any kind of subfeature is added to this
\&           feature. add_sub_SeqFeature() already does this.
\& Returns : 
\& Args    : A Bio::SeqFeatureI implementing object.
.Ve
.Sh "_parse"
.IX Subsection "_parse"
.Vb 6
\& Title   : _parse
\& Usage   :
\& Function: Parsing hints
\& Example :
\& Returns :
\& Args    :
.Ve
.Sh "_tag_value"
.IX Subsection "_tag_value"
.Vb 6
\& Title   : _tag_value
\& Usage   : 
\& Function: For internal use only. Convenience method for those tags that
\&           may only have a single value.
\& Returns : 
\& Args    :
.Ve
