.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:35 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::Tools::SeqStats 3"
.TH Bio::Tools::SeqStats 3 "perl v5.6.0" "2001-06-10" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::Tools::SeqStats \- Object holding statistics for one particular sequence
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # build a primary nucleic acid or protein sequence object somehow
\&    # then build a statistics object from the sequence object
.Ve
.Vb 4
\&        $seqobj = Bio::PrimarySeq->new(-seq=>'ACTGTGGCGTCAACTG', 
\&                                                                        -moltype=>'dna', 
\&                                                                        -id=>'test');
\&        $seq_stats  =  Bio::Tools::SeqStats->new(-seq=>$seqobj);
.Ve
.Vb 8
\&        # obtain a hash of counts of each type of monomer 
\&        # (ie amino or nucleic acid)
\&        print "\enMonomer counts using statistics object\en";
\&        $seq_stats  =  Bio::Tools::SeqStats->new(-seq=>$seqobj);
\&        $hash_ref = $seq_stats->count_monomers();  # eg for DNA sequence
\&        foreach $base (sort keys %$hash_ref) {
\&                print "Number of bases of type ", $base, "= ", %$hash_ref->{$base},"\en";
\&        }
.Ve
.Vb 6
\&        # or obtain the count directly without creating a new statistics object
\&        print "\enMonomer counts without statistics object\en";
\&        $hash_ref = Bio::Tools::SeqStats->count_monomers($seqobj);
\&        foreach $base (sort keys %$hash_ref) {
\&                print "Number of bases of type ", $base, "= ", %$hash_ref->{$base},"\en";
\&        }
.Ve
.Vb 6
\&        # obtain hash of counts of each type of codon in a nucleic acid sequence
\&        print "\enCodon counts using statistics object\en";
\&        $hash_ref = $seq_stats-> count_codons();  # for nucleic acid sequence
\&        foreach $base (sort keys %$hash_ref) {
\&                print "Number of codons of type ", $base, "= ", %$hash_ref->{$base},"\en";
\&        }
.Ve
.Vb 6
\&        #  or
\&        print "\enCodon counts without statistics object\en";
\&        $hash_ref = Bio::Tools::SeqStats->count_codons($seqobj);
\&        foreach $base (sort keys %$hash_ref) {
\&                print "Number of codons of type ", $base, "= ", %$hash_ref->{$base},"\en";
\&        }
.Ve
.Vb 8
\&        # Obtain the molecular weight of a sequence. Since the sequence may contain 
\&        # ambiguous monomers, the molecular weight is returned as a (reference to) a 
\&        # two element array containing greatest lower bound (GLB) and least upper bound 
\&        # (LUB) of the molecular weight 
\&        $weight = $seq_stats->get_mol_wt();
\&        print "\enMolecular weight (using statistics object) of sequence ", $seqobj->id(), 
\&             " is between ", $$weight[0], " and " , 
\&             $$weight[1], "\en";
.Ve
.Vb 5
\&        #  or
\&        $weight = Bio::Tools::SeqStats->get_mol_wt($seqobj);
\&        print "\enMolecular weight (without statistics object) of sequence ", $seqobj->id(), 
\&             " is between ", $$weight[0], " and " , 
\&             $$weight[1], "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Tools::SeqStats is a lightweight object for the calculation of
simple statistical and numerical properties of a sequence. By
\&\*(L"lightweight\*(R" I mean that only \*(L"primary\*(R" sequences are handled by the
object.  The calling script needs to create the appropriate primary
sequence to be passed to SeqStats if statistics on a sequence feature
are required.  Similarly if a codon count is desired for a
frame-shifted sequence and/or a negative strand sequence, the calling
script needs to create that sequence and pass it to the SeqStats
object.
.PP
SeqStats can be called in two distinct manners.  If only a single
computation is required on a given sequence object, the method can be
called easily using the SeqStats object directly:
.PP
.Vb 1
\&        $weight = Bio::Tools::SeqStats->get_mol_wt($seqobj);
.Ve
Alternately, if several computations will be required on a given
sequence object, an \*(L"instance\*(R" statistics object can be constructed
and used for the method calls:
.PP
.Vb 4
\&        $seq_stats  =  Bio::Tools::SeqStats->new($seqobj);
\&        $monomers = $seq_stats->count_monomers();
\&        $codons = $seq_stats->count_codons();
\&        $weight = $seq_stats->get_mol_wt();
.Ve
As currently implemented the object can return the following values from a sequence:
	* The molecular weight of the sequence: \fIget_mol_wt()\fR
	* The number of each type of monomer present: \fIcount_monomers()\fR
	* The number of each codon present in a nucleic acid sequence: \fIcount_codons()\fR
.PP
For dna (and rna) sequences, single-stranded weights are returned. The
molecular weights are calculated for neutral \- ie not ionized \-
nucleic acids. The returned weight is the sum of the
base-sugar-phosphate residues of the chain plus one weight of water to
to account for the additional \s-1OH\s0 on the phosphate of the 5' residue
and the additional H on the sugar ring of the 3' residue.  Note that
this leads to a difference of 18 in calculated molecular weights
compared to some other available programs (eg Informax VectorNTI).
.PP
Note that since sequences may contain ambiguous monomers (eg \*(L"M\*(R"
meaning \*(L"A\*(R" or \*(L"C\*(R" in a nucleic acid sequence), the method get_mol_wt
returns a two-element array containing the greatest lower bound and
least upper bound of the molecule. (For a sequence with no ambiguous
monomers, the two elements of the returned array will be equal.) The
method \fIcount_codons()\fR handles ambiguous bases by simply counting all
ambiguous codons together and issuing a warning to that effect.
.SH "DEVELOPERS NOTES"
.IX Header "DEVELOPERS NOTES"
Ewan moved it from Bio::SeqStats to Bio::Tools::SeqStats
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org               - General discussion
\&  http://bio.perl.org/MailList.html   - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
 the bugs and their resolution.
 Bug reports can be submitted via email or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \-  Peter Schattner"
.IX Header "AUTHOR -  Peter Schattner"
Email schattner@alum.mit.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal methods are
usually preceded with a _
.Sh "count_monomers"
.IX Subsection "count_monomers"
.Vb 13
\& Title   : count_monomers
\& Usage   : $rcount = $seq_stats->count_monomers(); 
\&        or $rcount = $seq_stats->Bio::Tools::SeqStats->($seqobj);
\& Function: Counts the number of each type of monomer (amino acid or
\&           base) in the sequence.
\& Example :
\& Returns : Reference to a hash in which keys are letters of the
\&           genetic alphabet used and values are number of occurrences
\&           of the letter in the sequence.
\& Args    : None or reference to sequence object
\& Throws : Throws an exception if type of sequence is unknown (ie amino
\&          or nucleic)or if unknown letter in alphabet. Ambiguous
\&          elements are allowed.
.Ve
.Sh "get_mol_wt"
.IX Subsection "get_mol_wt"
.Vb 5
\& Title   : get_mol_wt
\& Usage   : $wt = $seqobj->get_mol_wt() or 
\&           $wt = Bio::Tools::SeqStats ->get_mol_wt($seqobj);
\& Function: Calculate molecular weight of sequence
\& Example :
.Ve
.Vb 9
\& Returns : Reference to two element array containing lower and upper
\&           bounds of molecule molecular weight. (For dna (and rna)
\&           sequences, single-stranded weights are returned.)  If
\&           sequence contains no ambiguous elements, both entries in
\&           array are equal to molecular weight of molecule.  
\& Args    : None or reference to sequence object
\& Throws  : Exception if type of sequence is unknown (ie not amino or
\&           nucleic) or if unknown letter in alphabet. Ambiguous
\&           elements are allowed.
.Ve
.Sh "count_codons"
.IX Subsection "count_codons"
.Vb 3
\& Title   : count_codons
\& Usage   : $rcount = $seqstats->count_codons (); or 
\&           $rcount = Bio::Tools::SeqStats->count_codons($seqobj);
.Ve
.Vb 8
\& Function: Counts the number of each type of codons in a given frame 
\&           for a dna or rna sequence.
\& Example :
\& Returns : Reference to a hash in which keys are codons of the genetic
\&           alphabet used and values are number of occurrences of the
\&           codons in the sequence. All codons with "ambiguous" bases
\&           are counted together.
\& Args    : None or reference to sequence object
.Ve
.Vb 1
\& Throws  : an exception if type of sequence is unknown or protein.
.Ve
.Sh "_is_alphabet_strict"
.IX Subsection "_is_alphabet_strict"
.Vb 8
\& Title   :   _is_alphabet_strict
\& Usage   :  
\& Function: internal function to determine whether there are 
\&           any ambiguous elements in the current sequence
\& Example :
\& Returns : 1 if strict alphabet is being used, 
\&           0 if ambiguous elements are present
\& Args    :
.Ve
.Vb 3
\& Throws  : an exception if type of sequence is unknown (ie amino or
\&           nucleic) or if unknown letter in alphabet. Ambiguous
\&           monomers are allowed.
.Ve
.Sh "_print_data"
.IX Subsection "_print_data"
.Vb 5
\& Title   : _print_data
\& Usage   : $seqobj->_print_data() or Bio::Tools::SeqStats->_print_data();
\& Function: Displays dna / rna parameters (used for debugging)
\& Returns : 1
\& Args    : None
.Ve
Used for debugging.
