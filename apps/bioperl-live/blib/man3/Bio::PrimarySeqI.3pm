.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:36 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::PrimarySeqI 3"
.TH Bio::PrimarySeqI 3 "perl v5.6.0" "2001-05-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::PrimarySeqI \- Interface definition for a Bio::PrimarySeq
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # get a Bio::PrimarySeqI compliant object somehow
.Ve
.Vb 1
\&    # to test this is a seq object
.Ve
.Vb 1
\&    $obj->isa("Bio::PrimarySeqI") || $obj->throw("$obj does not implement the Bio::PrimarySeqI interface");
.Ve
.Vb 1
\&    # accessors
.Ve
.Vb 6
\&    $string    = $obj->seq();
\&    $substring = $obj->subseq(12,50);
\&    $display   = $obj->display_id(); # for human display
\&    $id        = $obj->primary_id(); # unique id for this object, implementation defined
\&    $unique_key= $obj->accession_number();
\&                       # unique biological id
.Ve
.Vb 1
\&    # object manipulation
.Ve
.Vb 6
\&    eval {
\&        $rev    = $obj->revcom();
\&    };
\&    if( $@ ) {
\&        $obj->throw("Could not reverse complement. Probably not DNA. Actual exception\en$@\en");
\&    }
.Ve
.Vb 1
\&    $trunc = $obj->trunc(12,50);
.Ve
.Vb 1
\&    # $rev and $trunc are Bio::PrimarySeqI compliant objects
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object defines an abstract interface to basic sequence
information. PrimarySeq is an object just for the sequence and its
\&\fIname\fR\|(s), nothing more. Seq is the larger object complete with
features. There is a pure perl implementation of this in
Bio::PrimarySeq. If you just want to use Bio::PrimarySeq objects, then
please read that module first. This module defines the interface, and
is of more interest to people who want to wrap their own Perl
Objects/RDBs/FileSystems etc in way that they \*(L"are\*(R" bioperl sequence
objects, even though it is not using Perl to store the sequence etc.
.PP
This interface defines what bioperl consideres necessary to \*(L"be\*(R" a
sequence, without providing an implementation of this. (An
implementation is provided in Bio::PrimarySeq). If you want to provide
a Bio::PrimarySeq 'compliant' object which in fact wraps another
object/database/out-of-perl experience, then this is the correct thing
to wrap, generally by providing a wrapper class which would inheriet
from your object and this Bio::PrimarySeqI interface. The wrapper class
then would have methods lists in the \*(L"Implementation Specific
Functions\*(R" which would provide these methods for your object.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org          - General discussion
\&  http://bio.perl.org/MailList.html             - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@sanger.ac.uk
.PP
Describe contact details here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal methods are usually preceded with a _
.SH "Implementation Specific Functions"
.IX Header "Implementation Specific Functions"
These functions are the ones that a specific implementation must
define.
.Sh "seq"
.IX Subsection "seq"
.Vb 10
\& Title   : seq
\& Usage   : $string    = $obj->seq()
\& Function: Returns the sequence as a string of letters. The
\&           case of the letters is left up to the implementer.
\&           Suggested cases are upper case for proteins and lower case for
\&           DNA sequence (IUPAC standard),
\&           but implementations are suggested to keep an open mind about
\&           case (some users... want mixed case!)
\& Returns : A scalar
\& Status  : Virtual
.Ve
.Sh "subseq"
.IX Subsection "subseq"
.Vb 5
\& Title   : subseq
\& Usage   : $substring = $obj->subseq(10,40);
\& Function: returns the subseq from start to end, where the first base
\&           is 1 and the number is inclusive, ie 1-2 are the first two
\&           bases of the sequence
.Ve
.Vb 1
\&           Start cannot be larger than end but can be equal
.Ve
.Vb 3
\& Returns : a string
\& Args    :
\& Status  : Virtual
.Ve
.Sh "display_id"
.IX Subsection "display_id"
.Vb 3
\& Title   : display_id
\& Usage   : $id_string = $obj->display_id();
\& Function: returns the display id, aka the common name of the Sequence object.
.Ve
.Vb 10
\&           The semantics of this is that it is the most likely string
\&           to be used as an identifier of the sequence, and likely to
\&           have "human" readability.  The id is equivalent to the ID
\&           field of the GenBank/EMBL databanks and the id field of the
\&           Swissprot/sptrembl database. In fasta format, the >(\eS+) is
\&           presumed to be the id, though some people overload the id
\&           to embed other information. Bioperl does not use any
\&           embedded information in the ID field, and people are
\&           encouraged to use other mechanisms (accession field for
\&           example, or extending the sequence object) to solve this.
.Ve
.Vb 5
\&           Notice that $seq->id() maps to this function, mainly for
\&           legacy/convience issues
\& Returns : A string
\& Args    : None
\& Status  : Virtual
.Ve
.Sh "accession_number"
.IX Subsection "accession_number"
.Vb 8
\& Title   : accession_number
\& Usage   : $unique_biological_key = $obj->accession_number;
\& Function: Returns the unique biological id for a sequence, commonly
\&           called the accession_number. For sequences from established
\&           databases, the implementors should try to use the correct
\&           accession number. Notice that primary_id() provides the
\&           unique id for the implemetation, allowing multiple objects
\&           to have the same accession number in a particular implementation.
.Ve
.Vb 5
\&           For sequences with no accession number, this method should return
\&           "unknown".
\& Returns : A string
\& Args    : None
\& Status  : Virtual
.Ve
.Sh "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $unique_implementation_key = $obj->primary_id;
\& Function: Returns the unique id for this object in this
\&           implementation. This allows implementations to manage
\&           their own object ids in a way the implementaiton can control
\&           clients can expect one id to map to one object.
.Ve
.Vb 5
\&           For sequences with no accession number, this method should return
\&           a stringified memory location.
\& Returns : A string
\& Args    : None
\& Status  : Virtual
.Ve
.Sh "can_call_new"
.IX Subsection "can_call_new"
.Vb 9
\& Title   : can_call_new
\& Usage   : if( $obj->can_call_new ) {
\&             $newobj = $obj->new( %param );
\&         }
\& Function: can_call_new returns 1 or 0 depending
\&           on whether an implementation allows new
\&           constructor to be called. If a new constructor
\&           is allowed, then it should take the followed hashed
\&           constructor list.
.Ve
.Vb 8
\&           $myobject->new( -seq => $sequence_as_string,
\&                           -display_id  => $id
\&                           -accession_number => $accession
\&                           -moltype => 'dna',
\&                           );
\& Example :
\& Returns : 1 or 0
\& Args    :
.Ve
.Sh "moltype"
.IX Subsection "moltype"
.Vb 4
\& Title   : moltype
\& Usage   : if( $obj->moltype eq 'dna' ) { /Do Something/ }
\& Function: Returns the type of sequence being one of
\&           'dna', 'rna' or 'protein'. This is case sensitive.
.Ve
.Vb 2
\&           This is not called <type> because this would cause
\&           upgrade problems from the 0.5 and earlier Seq objects.
.Ve
.Vb 5
\& Returns : a string either 'dna','rna','protein'. NB - the object must
\&           make a call of the type - if there is no type specified it
\&           has to guess.
\& Args    : none
\& Status  : Virtual
.Ve
.SH "Optional Implementation Functions"
.IX Header "Optional Implementation Functions"
The following functions rely on the above functions. A implementing
class does not need to provide these functions, as they will be
provided by this class, but is free to override these functions.
.PP
All of \fIrevcom()\fR, \fItrunc()\fR, and \fItranslate()\fR create new sequence
objects. They will call \fInew()\fR on the class of the sequence object
instance passed as argument, unless \fIcan_call_new()\fR returns \s-1FALSE\s0. In
the latter case a Bio::PrimarySeq object will be created. Implementors
which really want to control how objects are created (eg, for object
persistence over a database, or objects in a \s-1CORBA\s0 framework), they
are encouraged to override these methods
.Sh "revcom"
.IX Subsection "revcom"
.Vb 5
\& Title   : revcom
\& Usage   : $rev = $seq->revcom()
\& Function: Produces a new Bio::PrimarySeqI implementing object which
\&           is the reversed complement of the sequence. For protein
\&           sequences this throws an exception of "Sequence is a protein. Cannot revcom"
.Ve
.Vb 3
\&           The id is the same id as the orginal sequence, and the accession number
\&           is also indentical. If someone wants to track that this sequence has be
\&           reversed, it needs to define its own extensions
.Ve
.Vb 1
\&           To do an inplace edit of an object you can go:
.Ve
.Vb 1
\&           $seq = $seq->revcom();
.Ve
.Vb 2
\&           This of course, causes Perl to handle the garbage collection of the old
\&           object, but it is roughly speaking as efficient as an inplace edit.
.Ve
.Vb 2
\& Returns : A new (fresh) Bio::PrimarySeqI object
\& Args    : none
.Ve
.Sh "trunc"
.IX Subsection "trunc"
.Vb 3
\& Title   : trunc
\& Usage   : $subseq = $myseq->trunc(10,100);
\& Function: Provides a truncation of a sequence,
.Ve
.Vb 3
\& Example :
\& Returns : a fresh Bio::PrimarySeqI implementing object
\& Args    : Two integers denoting first and last base of the sub-sequence.
.Ve
.Sh "translate"
.IX Subsection "translate"
.Vb 5
\& Title   : translate
\& Usage   : $protein_seq_obj = $dna_seq_obj->translate
\&           #if full CDS expected:
\&           $protein_seq_obj = $cds_seq_obj->translate(undef,undef,undef,undef,1);
\& Function:
.Ve
.Vb 2
\&           Provides the translation of the DNA sequence using full
\&           IUPAC ambiguities in DNA/RNA and amino acid codes.
.Ve
.Vb 4
\&           The full CDS translation is identical to EMBL/TREMBL
\&           database translation. Note that the trailing terminator
\&           character is removed before returning the translation
\&           object.
.Ve
.Vb 2
\&           Note: if you set $dna_seq_obj->verbose(1) you will get a
\&           warning if the first codon is not a valid initiator.
.Ve
.Vb 7
\& Returns : A Bio::PrimarySeqI implementing object
\& Args    : character for terminator (optional) defaults to '*'
\&           character for unknown amino acid (optional) defaults to 'X'
\&           frame (optional) valid values 0, 1, 2, defaults to 0
\&           codon table id (optional) defaults to 1
\&           complete coding sequence expected, defaults to 0 (false)
\&           boolean, throw exception if not complete CDS (true) or defaults to warning (false)
.Ve
.Sh "id"
.IX Subsection "id"
.Vb 7
\& Title   : id
\& Usage   : $id = $seq->id()
\& Function: ID of the sequence. This should normally be (and actually is in
\&           the implementation provided here) just a synonym for display_id().
\& Example :
\& Returns : A string.
\& Args    :
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 6
\& Title   : length
\& Usage   : $len = $seq->length()
\& Function:
\& Example :
\& Returns : integer representing the length of the sequence.
\& Args    :
.Ve
.Sh "desc"
.IX Subsection "desc"
.Vb 7
\& Title   : desc
\& Usage   : $seq->desc($newval);
\&           $description = $seq->desc();
\& Function: Get/set description text for a seq object
\& Example :
\& Returns : value of desc
\& Args    : newvalue (optional)
.Ve
.SH "Private functions"
.IX Header "Private functions"
These are some private functions for the PrimarySeqI interface. You do not
need to implement these functions
.Sh "_attempt_to_load_Seq"
.IX Subsection "_attempt_to_load_Seq"
.Vb 6
\& Title   : _attempt_to_load_Seq
\& Usage   :
\& Function:
\& Example :
\& Returns :
\& Args    :
.Ve
