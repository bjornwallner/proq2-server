.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:48 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::SimpleAlign 3"
.TH Bio::SimpleAlign 3 "perl v5.6.0" "2001-06-14" "User Contributed Perl Documentation"
.UC
.SH "NAME"
SimpleAlign \- Multiple alignments held as a set of sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # use Bio::AlignIO to read in the alignment
\&  $str = Bio::AlignIO->new('-file' => 't/data/testaln.pfam');
\&  $aln = $str->next_aln();
.Ve
.Vb 7
\&  # some descriptors
\&  print $aln->length, "\en";
\&  print $aln->no_residues, "\en";
\&  print $aln->is_flush, "\en";
\&  print $aln->no_sequences, "\en";
\&  print $aln->percentage_identity, "\en";
\&  print $aln->consensus_string(50), "\en";
.Ve
.Vb 2
\&  # find the position in the alignment for a sequence location
\&  $pos = $aln->column_from_residue_number('1433_LYCES', 14); # = 6;
.Ve
.Vb 8
\&  # extract sequences and check values for the alignment column $pos
\&  foreach $seq ($aln->each_seq) {
\&      $res = $seq->subseq($pos, $pos);
\&      $count{$res}++;
\&  }
\&  foreach $res (keys %count) {
\&      printf "Res: %s  Count: %2d\en", $res, $count{$res};
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SimpleAlign handles multiple alignments of sequences. It is very
permissive of types (it won\e't insist on things being all same length
etc): really it is a SequenceSet explicitly held in memory with a
whole series of built in manipulations and especially file format
systems for read/writing alignments.
.PP
SimpleAlign basically views an alignment as an immutable block of
text.  SimpleAlign *is not* the object to be using if you want to
perform complex alignment manipulations.  These functions are much
better done by UnivAln by Georg Fuellen.
.PP
However for lightweight display/formatting and minimal manipulation
(e.g. removing all-gaps columns) \- this is the one to use.
.PP
SimpleAlign uses a subclass of the Bio::PrimarySeq manpage class
the Bio::LocatableSeq manpage to store its sequences. These are subsequences
with a start and end positions in the parent reference sequence.
.PP
Tricky concepts. SimpleAlign expects name,start,end to be 'unique' in
the alignment, and this is the key for the internal hashes.
(name,start,end is abbreviated nse in the code). However, in many
cases people don\e't want the name/start-end to be displayed: either
multiple names in an alignment or names specific to the alignment
(\s-1ROA1_HUMAN_1\s0, \s-1ROA1_HUMAN_2\s0 etc). These names are called
\&'displayname', and generally is what is used to print out the
alignment. They default to name/start-end.
.PP
The SimpleAlign Module came from Ewan Birney\e's Align module.
.SH "PROGRESS"
.IX Header "PROGRESS"
SimpleAlign is being slowly converted to bioperl coding standards,
mainly by Ewan.
.Ip "Use Bio::Root::Object \- done" 3
.IX Item "Use Bio::Root::Object - done"
.Ip "Use proper exceptions \- done" 3
.IX Item "Use proper exceptions - done"
.Ip "Use hashed constructor \- not done!" 3
.IX Item "Use hashed constructor - not done!"
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules.  Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&   bioperl-l@bioperl.org             - General discussion
\&   http://bioperl.org/MailList.shtml - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&    bioperl-bugs@bio.perl.org
\&    http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Ewan Birney, birney@sanger.ac.uk
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the Bio::LocatableSeq.pm manpage
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "Modifier methods"
.IX Header "Modifier methods"
These methods modify the \s-1MSE\s0 by adding, removing or shuffling complete
sequences.
.Sh "add_seq"
.IX Subsection "add_seq"
.Vb 7
\& Title     : add_seq
\& Usage     : $myalign->add_seq($newseq);
\& Function  : Adds another sequence to the alignment. *Does not* align
\&             it - just adds it to the hashes.
\& Returns   : nothing
\& Args      : a L<Bio::LocatableSeq> object
\&             order (optional)
.Ve
.Sh "remove_seq"
.IX Subsection "remove_seq"
.Vb 5
\& Title     : remove_seq
\& Usage     : $aln->remove_seq($seq);
\& Function  : Removes a single sequence from an alignment
\& Returns   :
\& Argument  : a Bio::LocatableSeq object
.Ve
.Sh "purge"
.IX Subsection "purge"
.Vb 3
\& Title   : purge
\& Usage   : $aln->purge(0.7);
\& Function:
.Ve
.Vb 1
\&           Removes sequences above whatever %id.
.Ve
.Vb 2
\&           This function will grind on large alignments. Beware!
\&           (perhaps not ideally implemented)
.Ve
.Vb 3
\& Example :
\& Returns : An array of the removed sequences
\& Args    :
.Ve
.Sh "sort_alphabetically"
.IX Subsection "sort_alphabetically"
.Vb 3
\& Title     : sort_alphabetically
\& Usage     : $ali->sort_alphabetically
\& Function  :
.Ve
.Vb 2
\&             Changes the order of the alignemnt to alphabetical on name 
\&             followed by numerical by number.
.Ve
.Vb 2
\& Returns   : 
\& Argument  :
.Ve
.SH "Sequence selection methods"
.IX Header "Sequence selection methods"
Methods returning one or more sequences objects.
.Sh "each_seq"
.IX Subsection "each_seq"
.Vb 5
\& Title     : each_seq
\& Usage     : foreach $seq ( $align->each_seq() ) 
\& Function  : Gets an array of Seq objects from the alignment
\& Returns   : an array
\& Argument  :
.Ve
.Sh "each_alphabetically"
.IX Subsection "each_alphabetically"
.Vb 3
\& Title     : each_alphabetically
\& Usage     : foreach $seq ( $ali->each_alphabetically() )
\& Function  :
.Ve
.Vb 3
\&             Returns an array of sequence object sorted alphabetically 
\&             by name and then by start point.
\&             Does not change the order of the alignment
.Ve
.Vb 2
\& Returns   : 
\& Argument  :
.Ve
.Sh "each_seq_with_id"
.IX Subsection "each_seq_with_id"
.Vb 3
\& Title     : each_seq_with_id
\& Usage     : foreach $seq ( $align->each_seq_with_id() ) 
\& Function  :
.Ve
.Vb 3
\&             Gets an array of Seq objects from the
\&             alignment, the contents being those sequences
\&             with the given name (there may be more than one)
.Ve
.Vb 2
\& Returns   : an array
\& Argument  : a seq name
.Ve
.Sh "get_seq_by_pos"
.IX Subsection "get_seq_by_pos"
.Vb 3
\& Title     : get_seq_by_pos
\& Usage     : $seq = $aln->get_seq_by_pos(3) # third sequence from the alignment
\& Function  :
.Ve
.Vb 3
\&             Gets a sequence based on its position in the alignment.
\&             Numbering starts from 1.  Sequence positions larger than
\&             no_sequences() will thow an error.
.Ve
.Vb 2
\& Returns   : a Bio::LocatableSeq object
\& Args      : positive integer for the sequence osition
.Ve
.SH "Create new alignments"
.IX Header "Create new alignments"
The result of these methods are horizontal or vertical subsets of the
current \s-1MSE\s0.
.Sh "select"
.IX Subsection "select"
.Vb 3
\& Title     : select
\& Usage     : $aln2 = $aln->select(1, 3) # three first sequences
\& Function  :
.Ve
.Vb 3
\&             Creates a new alignment from a continuous subset of
\&             sequences.  Numbering starts from 1.  Sequence positions
\&             larger than no_sequences() will thow an error.
.Ve
.Vb 3
\& Returns   : a Bio::SimpleAlign object
\& Args      : positive integer for the first sequence
\&             positive integer for the last sequence to include (optional)
.Ve
.Sh "slice"
.IX Subsection "slice"
.Vb 3
\& Title     : slice
\& Usage     : $aln2 = $aln->slice(20, 30)
\& Function  :
.Ve
.Vb 5
\&             Creates a slice from the alignment inclusive of start and
\&             end columns.  Sequences with no residues in the slice are
\&             excluded from the new alignment and a warning is printed.
\&             Slice beyond the length of the sequence does not do
\&             padding.
.Ve
.Vb 3
\& Returns   : a Bio::SimpleAlign object
\& Args      : positive integer for start column 
\&             positive integer for end column
.Ve
.SH "Change sequences within the MSE"
.IX Header "Change sequences within the MSE"
These methods affect characters in all sequences without changeing the
alignment.
.Sh "map_chars"
.IX Subsection "map_chars"
.Vb 3
\& Title     : map_chars
\& Usage     : $ali->map_chars('\e.','-')
\& Function  :
.Ve
.Vb 2
\&             Does a s/$arg1/$arg2/ on the sequences. Useful for gap
\&             characters
.Ve
.Vb 3
\&             Notice that the from (arg1) is interpretted as a regex,
\&             so be careful about quoting meta characters (eg
\&             $ali->map_chars('.','-') wont do what you want)
.Ve
.Vb 3
\& Returns   : 
\& Argument  : 'from' rexexp
\&             'to' string
.Ve
.Sh "uppercase"
.IX Subsection "uppercase"
.Vb 5
\& Title     : uppercase()
\& Usage     : $ali->uppercase()
\& Function  : Sets all the sequences to uppercase
\& Returns   : 
\& Argument  :
.Ve
.Sh "match"
.IX Subsection "match"
.Vb 3
\& Title     : match()
\& Usage     : $ali->match()
\& Function  :
.Ve
.Vb 3
\&             Goes through all columns and changes residues that are
\&             identical to residue in first sequence to match '.'
\&             character. Sets L<match_char>.
.Ve
.Vb 4
\&             USE WITH CARE: Most MSE formats do not support match
\&             characters in sequences, so this is mostly for output
\&             only. NEXUS format (L<Bio::AlignIO::nexus>) can handle
\&             it.
.Ve
.Vb 2
\& Returns   : 1
\& Argument  : a match character, optional, defaults to '.'
.Ve
.Sh "unmatch"
.IX Subsection "unmatch"
.Vb 3
\& Title     : unmatch()
\& Usage     : $ali->unmatch()
\& Function  :
.Ve
.Vb 1
\&             Undoes the effect of method L<match>. Unsets L<match_char>.
.Ve
.Vb 2
\& Returns   : 1
\& Argument  : a match character, optional, defaults to '.'
.Ve
.SH "MSE attibutes"
.IX Header "MSE attibutes"
Methods for setting and reading the \s-1MSE\s0 attributes. 
.PP
Note that the methods defining character semantics depend on the user
to set them sensibly.  They are needed only by certain input/output
methods. Unset them by setting to an empty string ('').
.Sh "id"
.IX Subsection "id"
.Vb 5
\& Title     : id
\& Usage     : $myalign->id("Ig")
\& Function  : Gets/sets the id field of the alignment
\& Returns   : An id string
\& Argument  : An id string (optional)
.Ve
.Sh "missing_char"
.IX Subsection "missing_char"
.Vb 7
\& Title     : missing_char
\& Usage     : $myalign->missing_char("?")
\& Function  : Gets/sets the missing_char attribute of the alignment
\&             It is generally recommended to set it to 'n' or 'N' 
\&             for nucleotides and to 'X' for protein. 
\& Returns   : An missing_char string,
\& Argument  : An missing_char string (optional)
.Ve
.Sh "match_char"
.IX Subsection "match_char"
.Vb 5
\& Title     : match_char
\& Usage     : $myalign->match_char('.')
\& Function  : Gets/sets the match_char attribute of the alignment
\& Returns   : An match_char string,
\& Argument  : An match_char string (optional)
.Ve
.Sh "gap_char"
.IX Subsection "gap_char"
.Vb 5
\& Title     : gap_char
\& Usage     : $myalign->gap_char('-')
\& Function  : Gets/sets the gap_char attribute of the alignment
\& Returns   : An gap_char string, defaults to '-'
\& Argument  : An gap_char string (optional)
.Ve
.SH "Alignment descriptors"
.IX Header "Alignment descriptors"
These read only methods describe the \s-1MSE\s0 in various ways.
.Sh "consensus_string"
.IX Subsection "consensus_string"
.Vb 9
\& Title     : consensus_string
\& Usage     : $str = $ali->consensus_string($threshold_percent)
\& Function  : Makes a consensus
\& Returns   : 
\& Argument  : Optional treshold ranging from 0 to 100.  
\&                If consensus residue appears in fewer than threshold %
\&                of the sequences at a given location, consensus_string
\&                will return a "?" at that location rather than the
\&                consensus letter. (Default value = 0%)
.Ve
.Sh "consensus_aa"
.IX Subsection "consensus_aa"
.Vb 9
\& Title     : consensus_aa
\& Usage     : $consensus_residue = $ali->consensus_aa($residue_number, $threshold_percent)
\& Function  : Makes a consensus
\& Returns   :
\& Argument  : Optional treshold ranging from 0 to 100.  
\&                If consensus residue appears in fewer than threshold %
\&                of the sequences at a given location, consensus_string
\&                will return a "?" at that location rather than the
\&                consensus letter. (Default value = 0%)
.Ve
.Sh "is_flush"
.IX Subsection "is_flush"
.Vb 10
\& Title     : is_flush
\& Usage     : if( $ali->is_flush() )
\&           : 
\&           :
\& Function  : Tells you whether the alignment 
\&           : is flush, ie all of the same length
\&           : 
\&           :
\& Returns   : 1 or 0
\& Argument  :
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 6
\& Title     : length()
\& Usage     : $len = $ali->length() 
\& Function  : Returns the maximum length of the alignment.
\&             To be sure the alignment is a block, use is_flush
\& Returns   : 
\& Argument  :
.Ve
.Sh "maxdisplayname_length"
.IX Subsection "maxdisplayname_length"
.Vb 3
\& Title     : maxdisplayname_length
\& Usage     : $ali->maxdisplayname_length()
\& Function  :
.Ve
.Vb 2
\&             Gets the maximum length of the displayname in the
\&             alignment. Used in writing out various MSE formats.
.Ve
.Vb 2
\& Returns   : integer
\& Argument  :
.Ve
.Sh "no_residues"
.IX Subsection "no_residues"
.Vb 5
\& Title     : no_residues
\& Usage     : $no = $ali->no_residues
\& Function  : number of residues in total in the alignment
\& Returns   : integer
\& Argument  :
.Ve
.Sh "no_sequences"
.IX Subsection "no_sequences"
.Vb 5
\& Title     : no_sequences
\& Usage     : $depth = $ali->no_sequences
\& Function  : number of sequence in the sequence alignment
\& Returns   : integer
\& Argument  :
.Ve
.Sh "percentage_identity"
.IX Subsection "percentage_identity"
.Vb 6
\& Title   : percentage_identity
\& Usage   : $id = $align->percentage_identity
\& Function: The function uses a fast method to calculate the average 
\&           percentage identity of the alignment
\& Returns : The average percentage identity of the alignment
\& Args    : None
.Ve
.SH "Alignment positions"
.IX Header "Alignment positions"
A method to map a sequence position into an alignment column.
.Sh "column_from_residue_number"
.IX Subsection "column_from_residue_number"
.Vb 3
\& Title   : column_from_residue_number
\& Usage   : $col = $ali->column_from_residue_number( $seqname, $resnumber)
\& Function:
.Ve
.Vb 4
\&           This function gives the position in the alignment
\&           (i.e. column number) of the given residue number in the
\&           sequence with the given name. For example, for the
\&           alignment
.Ve
.Vb 3
\&             Seq1/91-97 AC..DEF.GH
\&             Seq2/24-30 ACGG.RTY..
\&             Seq3/43-51 AC.DDEFGHI
.Ve
.Vb 3
\&           column_from_residue_number( "Seq1", 94 ) returns 5.
\&           column_from_residue_number( "Seq2", 25 ) returns 2.
\&           column_from_residue_number( "Seq3", 50 ) returns 9.
.Ve
.Vb 3
\&           An exception is thrown if the residue number would lie
\&           outside the length of the aligment
\&           (e.g. column_from_residue_number( "Seq2", 22 )
.Ve
.Vb 3
\&          Note: If the the parent sequence is represented by more than
\&          one alignment sequence and the residue number is present in
\&          them, this method finds only the first one.
.Ve
.Vb 5
\& Returns : A column number for the position in the alignment of the
\&           given residue in the given sequence (1 = first column)
\& Args    : A sequence id/name (not a name/start-end)
\&           A residue number in the whole sequence (not just that
\&           segment of it in the alignment)
.Ve
.SH "Sequence names"
.IX Header "Sequence names"
Methods to manipulate the display name. The default name based on the
sequence id and subsequence positions can be overridden in various
ways.
.Sh "displayname"
.IX Subsection "displayname"
.Vb 7
\& Title     : displayname
\& Usage     : $myalign->displayname("Ig", "IgA")
\& Function  : Gets/sets the display name of a sequence in the alignment
\&           :
\& Returns   : A display name string
\& Argument  : name of the sequence
\&             displayname of the sequence (optional)
.Ve
.Sh "set_displayname_count"
.IX Subsection "set_displayname_count"
.Vb 3
\& Title     : set_displayname_count
\& Usage     : $ali->set_displayname_count
\& Function  :
.Ve
.Vb 2
\&             Sets the names to be name_# where # is the number of
\&             times this name has been used.
.Ve
.Vb 2
\& Returns   : 
\& Argument  :
.Ve
.Sh "set_displayname_flat"
.IX Subsection "set_displayname_flat"
.Vb 6
\& Title     : set_displayname_flat
\& Usage     : $ali->set_displayname_flat()
\& Function  : Makes all the sequences be displayed as just their name,
\&             not name/start-end
\& Returns   : 1
\& Argument  :
.Ve
.Sh "set_displayname_normal"
.IX Subsection "set_displayname_normal"
.Vb 5
\& Title     : set_displayname_normal
\& Usage     : $ali->set_displayname_normal() 
\& Function  : Makes all the sequences be displayed as name/start-end
\& Returns   : 
\& Argument  :
.Ve
