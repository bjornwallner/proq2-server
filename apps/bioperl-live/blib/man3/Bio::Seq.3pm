.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:05 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::Seq 3"
.TH Bio::Seq 3 "perl v5.6.0" "2001-06-21" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::Seq \- Sequence object, with features
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    $seqio  = Bio::SeqIO->new ( '-format' => 'embl' , -file => 'myfile.dat');
\&    $seqobj = $seqio->next_seq();
.Ve
.Vb 1
\&    # features must implement Bio::SeqFeatureI
.Ve
.Vb 2
\&    @features = $seqobj->top_SeqFeatures(); # just top level
\&    @features = $seqobj->all_SeqFeatures(); # descend into sub features
.Ve
.Vb 3
\&    $seq      = $seqobj->seq(); # actual sequence as a string
\&    $seqstr   = $seqobj->subseq(10,50);
\&    $ann      = $seqobj->annotation(); # annotation object
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Seq object is a sequence with sequence features placed on them. The
Seq object contains a PrimarySeq object for the actual sequence and
also implements its interface.
.PP
In bioperl we have 3 main players that people are going to use
.PP
.Vb 5
\&  Bio::PrimarySeq - just the sequence and its names, nothing else.
\&  Bio::SeqFeatureI - a location on a sequence, potentially with a sequence.
\&                    and annotation
\&  Bio::Seq        - A sequence and a collection of seqfeatures (an aggregate) with
\&                    its own annotation.
.Ve
Although bioperl is not tied to file formats heavily, these distinctions do
map to file formats sensibly and for some bioinformaticians this might help
you:
.PP
.Vb 3
\&  Bio::PrimarySeq - Fasta file of a sequence
\&  Bio::SeqFeatureI - A single entry in an EMBL/GenBank/DDBJ feature table
\&  Bio::Seq        - A single EMBL/GenBank/DDBJ entry
.Ve
By having this split we avoid alot of nasty ciricular references
(seqfeatures can hold a reference to a sequence without the sequence
holding a reference to the seqfeature).
.PP
Ian Korf really helped in the design of the Seq and SeqFeature system.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org              - General discussion
\&  http://bio.perl.org/MailList.html  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl-bugs@bioperl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \- Ewan Birney, inspired by Ian Korf objects"
.IX Header "AUTHOR - Ewan Birney, inspired by Ian Korf objects"
Email birney@sanger.ac.uk
.PP
Describe contact details here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $seq    = Bio::Seq->new( -seq => 'ATGGGGGTGGTGGTACCCT',
\&                                    -id  => 'human_id',
\&                                    -accession_number => 'AL000012',
\&                                   );
.Ve
.Vb 4
\& Function: Returns a new seq object from
\&           basic constructors, being a string for the sequence
\&           and strings for id and accession_number
\& Returns : a new Bio::Seq object
.Ve
.SH "PrimarySeq interface"
.IX Header "PrimarySeq interface"
The primaryseq interface is the basic sequence getting
and setting methods found on all sequences.
.PP
These methods implement the PrimarySeq interface by delegating
to the primary_seq inside the object. This means that you
can use a Seq object wherever there is a PrimarySeq, and
of course, you are free to use these functions anyway.
.Sh "seq"
.IX Subsection "seq"
.Vb 9
\& Title   : seq
\& Usage   : $string    = $obj->seq()
\& Function: Returns the sequence as a string of letters. The
\&           case of the letters is left up to the implementer.
\&           Suggested cases are upper case for proteins and lower case for
\&           DNA sequence (IUPAC standard),
\&           but implementations are suggested to keep an open mind about
\&           case (some users... want mixed case!)
\& Returns : A scalar
.Ve
.Sh "validate_seq"
.IX Subsection "validate_seq"
.Vb 8
\& Title   : validate_seq
\& Usage   : if(! $seq->validate_seq($seq_str) ) {
\&                print "sequence $seq_str is not valid for an object of type ",
\&                      ref($seq), "\en";
\&           }
\& Function: Validates a given sequence string. A validating sequence string
\&           must be accepted by seq(). A string that does not validate will
\&           lead to an exception if passed to seq().
.Ve
.Vb 2
\&           The implementation provided here does not take moltype() into
\&           account. Allowed are all letters (A-Z) and '-','.', and '*'.
.Ve
.Vb 4
\& Example :
\& Returns : TRUE if the supplied sequence string is valid for the object, and
\&           FALSE otherwise.
\& Args    : The sequence string to be validated.
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 6
\& Title   : length
\& Usage   : $len = $seq->length()
\& Function:
\& Example :
\& Returns : integer representing the length of the sequence.
\& Args    :
.Ve
.Sh "subseq"
.IX Subsection "subseq"
.Vb 5
\& Title   : subseq
\& Usage   : $substring = $obj->subseq(10,40);
\& Function: returns the subseq from start to end, where the first base
\&           is 1 and the number is inclusive, ie 1-2 are the first two
\&           bases of the sequence
.Ve
.Vb 1
\&           Start cannot be larger than end but can be equal
.Ve
.Vb 2
\& Returns : a string
\& Args    :
.Ve
.Sh "display_id"
.IX Subsection "display_id"
.Vb 4
\& Title   : display_id
\& Usage   : $id_string = $obj->display_id($newid);
\& Function: returns or sets the display id, aka the common name of the
\&           Sequence object.
.Ve
.Vb 10
\&           The semantics of this is that it is the most likely string
\&           to be used as an identifier of the sequence, and likely to
\&           have "human" readability.  The id is equivalent to the ID
\&           field of the GenBank/EMBL databanks and the id field of the
\&           Swissprot/sptrembl database. In fasta format, the >(\eS+) is
\&           presumed to be the id, though some people overload the id
\&           to embed other information. Bioperl does not use any
\&           embedded information in the ID field, and people are
\&           encouraged to use other mechanisms (accession field for
\&           example, or extending the sequence object) to solve this.
.Ve
.Vb 4
\&           Notice that $seq->id() maps to this function, mainly for
\&           legacy/convience issues
\& Returns : A string
\& Args    : newid (optional)
.Ve
.Sh "accession_number"
.IX Subsection "accession_number"
.Vb 8
\& Title   : accession_number
\& Usage   : $unique_biological_key = $obj->accession_number;
\& Function: Returns the unique biological id for a sequence, commonly
\&           called the accession_number. For sequences from established
\&           databases, the implementors should try to use the correct
\&           accession number. Notice that primary_id() provides the
\&           unique id for the implemetation, allowing multiple objects
\&           to have the same accession number in a particular implementation.
.Ve
.Vb 4
\&           For sequences with no accession number, this method should return
\&           "unknown".
\& Returns : A string
\& Args    : None
.Ve
.Sh "desc"
.IX Subsection "desc"
.Vb 6
\& Title   : desc
\& Usage   : $seqobj->desc()
\& Function: Sets/Gets the description of the sequnce
\& Example :
\& Returns :
\& Args    :
.Ve
.Sh "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $unique_implementation_key = $obj->primary_id;
\& Function: Returns the unique id for this object in this
\&           implementation. This allows implementations to manage
\&           their own object ids in a way the implementaiton can control
\&           clients can expect one id to map to one object.
.Ve
.Vb 2
\&           For sequences with no natural id, this method should return
\&           a stringified memory location.
.Ve
.Vb 4
\&           Also notice that this method is B<not> delegated to the
\&           internal PrimarySeq object
\& Returns : A string
\& Args    : None
.Ve
.Sh "can_call_new"
.IX Subsection "can_call_new"
.Vb 9
\& Title   : can_call_new
\& Usage   : if( $obj->can_call_new ) {
\&             $newobj = $obj->new( %param );
\&           }
\& Function: can_call_new returns 1 or 0 depending
\&           on whether an implementation allows new
\&           constructor to be called. If a new constructor
\&           is allowed, then it should take the followed hashed
\&           constructor list.
.Ve
.Vb 8
\&           $myobject->new( -seq => $sequence_as_string,
\&                           -display_id  => $id
\&                           -accession_number => $accession
\&                           -moltype => 'dna',
\&                           );
\& Example :
\& Returns : 1 or 0
\& Args    :
.Ve
.Sh "moltype"
.IX Subsection "moltype"
.Vb 4
\& Title   : moltype
\& Usage   : if( $obj->moltype eq 'dna' ) { /Do Something/ }
\& Function: Returns the type of sequence being one of
\&           'dna', 'rna' or 'protein'. This is case sensitive.
.Ve
.Vb 2
\&           This is not called <type> because this would cause
\&           upgrade problems from the 0.5 and earlier Seq objects.
.Ve
.Vb 4
\& Returns : a string either 'dna','rna','protein'. NB - the object must
\&           make a call of the type - if there is no type specified it
\&           has to guess.
\& Args    : none
.Ve
.SH "Methods provided in the Bio::PrimarySeqI interface"
.IX Header "Methods provided in the Bio::PrimarySeqI interface"
These methods are inherited from the PrimarySeq interface
and work as one expects, building new Bio::Seq objects
or other information as expected.
.PP
Sequence Features are \fBnot\fR transfered to the new objects.
This is possibly a mistake. Anyone who feels the urge in
dealing with this is welcome to give it a go.
.Sh "revcom"
.IX Subsection "revcom"
.Vb 5
\& Title   : revcom
\& Usage   : $rev = $seq->revcom()
\& Function: Produces a new Bio::Seq object which
\&           is the reversed complement of the sequence. For protein
\&           sequences this throws an exception of "Sequence is a protein. Cannot revcom"
.Ve
.Vb 3
\&           The id is the same id as the orginal sequence, and the accession number
\&           is also indentical. If someone wants to track that this sequence has be
\&           reversed, it needs to define its own extensions
.Ve
.Vb 1
\&           To do an inplace edit of an object you can go:
.Ve
.Vb 1
\&           $seq = $seq->revcom();
.Ve
.Vb 2
\&           This of course, causes Perl to handle the garbage collection of the old
\&           object, but it is roughly speaking as efficient as an inplace edit.
.Ve
.Vb 2
\& Returns : A new (fresh) Bio::Seq object
\& Args    : none
.Ve
.Sh "trunc"
.IX Subsection "trunc"
.Vb 3
\& Title   : trunc
\& Usage   : $subseq = $myseq->trunc(10,100);
\& Function: Provides a truncation of a sequence,
.Ve
.Vb 3
\& Example :
\& Returns : a fresh Bio::Seq object
\& Args    :
.Ve
.Sh "id"
.IX Subsection "id"
.Vb 6
\& Title   : id
\& Usage   : $id = $seq->id()
\& Function: This is mapped on display_id
\& Example :
\& Returns :
\& Args    :
.Ve
.SH "Seq only methods"
.IX Header "Seq only methods"
These methods are specific to the Bio::Seq object, and not
found on the Bio::PrimarySeq object
.Sh "primary_seq"
.IX Subsection "primary_seq"
.Vb 6
\& Title   : primary_seq
\& Usage   : $obj->primary_seq($newval)
\& Function:
\& Example :
\& Returns : value of primary_seq
\& Args    : newvalue (optional)
.Ve
.Sh "annotation"
.IX Subsection "annotation"
.Vb 6
\& Title   : annotation
\& Usage   : $obj->annotation($seq_obj)
\& Function:
\& Example :
\& Returns : value of annotation
\& Args    : newvalue (optional)
.Ve
.Sh "add_SeqFeature"
.IX Subsection "add_SeqFeature"
.Vb 10
\& Title   : add_SeqFeature
\& Usage   : $seq->add_SeqFeature($feat);
\&           $seq->add_SeqFeature(@feat);
\& Function: Adds the given feature object (or each of an array of feature
\&           objects to the feature array of this
\&           sequence. The object passed is required to implement the
\&           Bio::SeqFeatureI interface.
\& Example :
\& Returns : TRUE on success
\& Args    : A Bio::SeqFeatureI implementing object, or an array of such objects.
.Ve
.Sh "flush_SeqFeatures"
.IX Subsection "flush_SeqFeatures"
.Vb 8
\& Title   : flush_SeqFeatures
\& Usage   : $seq->flush_SeqFeatures();
\& Function: Flushes all attached SeqFeatureI objects. To remove individual
\&           feature objects, first obtain all using all_SeqFeatures(), then
\&           flush and re-add those you want to keep.
\& Example :
\& Returns : TRUE on success
\& Args    :
.Ve
.Sh "top_SeqFeatures"
.IX Subsection "top_SeqFeatures"
.Vb 7
\& Title   : top_SeqFeatures
\& Usage   : @feat_ary = $seq->top_SeqFeatures();
\& Function: Returns the array of top-level features for this sequence object.
\&           Features which are not top-level are subfeatures of one or more
\&           of the returned feature objects, which means that you must
\&           traverse the subfeature arrays of each top-level feature object
\&           in order to traverse all features associated with this sequence.
.Ve
.Vb 5
\&           Use all_SeqFeatures() if you want the feature tree flattened into
\&           one single array.
\& Example :
\& Returns : An array of Bio::SeqFeatureI implementing objects.
\& Args    :
.Ve
.Sh "all_SeqFeatures"
.IX Subsection "all_SeqFeatures"
.Vb 7
\& Title   : all_SeqFeatures
\& Usage   : @feat_ary = $seq->all_SeqFeatures();
\& Function: Returns the tree of feature objects attached to this sequence
\&           object flattened into one single array. Top-level features will
\&           still contain their subfeature-arrays, which means that you
\&           will encounter subfeatures twice if you traverse the subfeature
\&           tree of the returned objects.
.Ve
.Vb 5
\&           Use top_SeqFeatures() if you want the array to contain only the
\&           top-level features.
\& Example :
\& Returns : An array of Bio::SeqFeatureI implementing objects.
\& Args    :
.Ve
.Sh "feature_count"
.IX Subsection "feature_count"
.Vb 6
\& Title   : feature_count
\& Usage   : $seq->feature_count()
\& Function: Return the number of SeqFeatures attached to a sequence
\& Example :
\& Returns : number of SeqFeatures
\& Args    : none
.Ve
.Sh "species"
.IX Subsection "species"
.Vb 6
\& Title   : species
\& Usage   :
\& Function: Gets or sets the species
\& Example : $species = $self->species();
\& Returns : Bio::Species object
\& Args    : Bio::Species object or none;
.Ve
