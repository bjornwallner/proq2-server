.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:20 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::Seq::RichSeq 3"
.TH Bio::Seq::RichSeq 3 "perl v5.6.0" "2001-06-01" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::Seq::RichSeq \- Module implementing a sequence created from a rich
sequence database entry
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Bio::Seq::RichSeqI and documentation of methods.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements Bio::Seq::RichSeqI, an interface for sequences
created from or created for entries from/of rich sequence databanks,
like \s-1EMBL\s0, GenBank, and SwissProt. Methods added to the Bio::SeqI
interface therefore focus on databank-specific information. Note that
not every rich databank format may use all of the properties provided.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
 to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                 - General discussion
\&  http://bio.perl.org/MailList.html             - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
 the bugs and their resolution.
 Bug reports can be submitted via email or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@ebi.ac.uk
.PP
Describe contact details here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $seq    = Bio::Seq::RichSeq->new( -seq => 'ATGGGGGTGGTGGTACCCT',
\&                                             -id  => 'human_id',
\&                                             -accession_number => 'AL000012',
\&                                            );
.Ve
.Vb 4
\& Function: Returns a new seq object from
\&           basic constructors, being a string for the sequence
\&           and strings for id and accession_number
\& Returns : a new Bio::Seq::RichSeq object
.Ve
.Sh "division"
.IX Subsection "division"
.Vb 5
\& Title   : division
\& Usage   : $obj->division($newval)
\& Function: 
\& Returns : value of division
\& Args    : newvalue (optional)
.Ve
.Sh "molecule"
.IX Subsection "molecule"
.Vb 5
\& Title   : molecule
\& Usage   : $obj->molecule($newval)
\& Function: 
\& Returns : type of molecule (DNA, mRNA)
\& Args    : newvalue (optional)
.Ve
.Sh "add_date"
.IX Subsection "add_date"
.Vb 6
\& Title   : add_date
\& Usage   : $self->add_date($datestr)
\& Function: adds a date
\& Example :
\& Returns : a date string or an array of such strings
\& Args    :
.Ve
.Sh "get_dates"
.IX Subsection "get_dates"
.Vb 6
\& Title   : get_dates
\& Usage   :
\& Function:
\& Example :
\& Returns : an array of date strings
\& Args    :
.Ve
.Sh "pid"
.IX Subsection "pid"
.Vb 7
\& Title   : pid
\& Usage   :
\& Function: Get (and set, depending on the implementation) the PID property
\&           for the sequence.
\& Example :
\& Returns : a string
\& Args    :
.Ve
.Sh "accession"
.IX Subsection "accession"
.Vb 4
\& Title   : accession
\& Usage   : $obj->accession($newval)
\& Function: Whilst the underlying sequence object does not 
\&           have an accession, so we need one here.
.Ve
.Vb 5
\&           In this implementation this is merely a synonym for
\&           accession_number().
\& Example : 
\& Returns : value of accession
\& Args    : newvalue (optional)
.Ve
.Sh "add_secondary_accession"
.IX Subsection "add_secondary_accession"
.Vb 6
\& Title   : add_secondary_accession
\& Usage   : $self->add_domment($ref)
\& Function: adds a secondary_accession
\& Example :
\& Returns : 
\& Args    : a string or an array of strings
.Ve
.Sh "get_secondary_accessions"
.IX Subsection "get_secondary_accessions"
.Vb 6
\& Title   : get_secondary_accessions
\& Usage   :
\& Function:
\& Example :
\& Returns : An array of strings
\& Args    :
.Ve
.Sh "seq_version"
.IX Subsection "seq_version"
.Vb 6
\& Title   : seq_version
\& Usage   : $obj->seq_version($newval)
\& Function: 
\& Example : 
\& Returns : value of seq_version
\& Args    : newvalue (optional)
.Ve
.Sh "keywords"
.IX Subsection "keywords"
.Vb 5
\& Title   : keywords
\& Usage   : $obj->keywords($newval)
\& Function: 
\& Returns : value of keywords (a string)
\& Args    : newvalue (optional) (a string)
.Ve
