.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:04 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "BIOSTART 1"
.TH BIOSTART 1 "perl v5.6.0" "2001-06-18" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bioperl \- Getting Started
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #!/usr/local/bin/perl
.Ve
.Vb 2
\&  use Bio::Seq;
\&  use Bio::SeqIO;
.Ve
.Vb 2
\&  $seqin = Bio::SeqIO->new( '-format' => 'EMBL' , -file => 'myfile.dat');
\&  $seqout= Bio::SeqIO->new( '-format' => 'Fasta', -file => '>output.fa');
.Ve
.Vb 10
\&  while((my $seqobj = $seqin->next_seq())) {
\&        print "Seen sequence ",$seqobj->display_id,", start of seq ",
\&               substr($seqobj->seq,1,10),"\en";
\&        if( $seqobj->moltype eq 'dna') {
\&            $rev = $seqobj->revcom;
\&            $id  = $seqobj->display_id();
\&            $id  = "$id.rev";
\&            $rev->display_id($id);
\&            $seqout->write_seq($rev);
\&         }
.Ve
.Vb 7
\&        foreach $feat ( $seqobj->top_SeqFeatures() ) {
\&           if( $feat->primary_tag eq 'exon' ) {
\&              print STDOUT "Location ",$feat->start,":",
\&                    $feat->end," GFF[",$feat->gff_string,"]\en";
\&           }
\&        }
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bioperl is a set of Perl modules that represent useful biological
objects. Some of the key objects include: Sequences, features on
sequences, databases of sequences, flat file representations of
sequences and similarity search results. 
.PP
Because bioperl is formed from Perl modules, there are no actual
useable programs in the distribution (this is not actually true.
In the scripts directory there are a few useful programs. But not
a great deal...). \fBYou\fR have to write the programs which use bioperl.
.PP
It is very easy to write programs using the bioperl modules, as alot
of the complex processing happens in the modules and not in the part
of the program which you have to write. The idea is that you can
connet up a number of the modules to do useful things. The synopsis
above gives a simple script which uses bioperl. Stepping through this
script, the lines mean the following things:
.PP
The first line indicates that in a \s-1UNIX\s0 manner, the /usr/local/bin/perl
executable is used to execute this script. Bioperl is not a new version
of perl, it just extends the standard perl for biological objects
.PP
.Vb 1
\&  #!/usr/local/bin/perl
.Ve
These use lines actually import the bioperl modules. Bio::Seq is the
bioperl main sequence object; Bio::SeqIO is the bioperl support for
sequence input/output into files
.PP
.Vb 2
\&  use Bio::Seq;
\&  use Bio::SeqIO;
.Ve
These two lines create two SeqIO streams: one for reading in sequences
and one for outputting sequences. Using the 
.PP
.Vb 1
\&  '-argument' => value
.Ve
syntax is common in bioperl. The file argument is like an argument
to \fIopen()\fR (notice that in the seqout case there is a greater-than
sign, indicating opening the file for writing). You can also pass in
filehandles or FileHandle objects by using the \-fh argument, see SeqIO
documentation for details. Many formarts in bioperl are handled,
including Fasta, \s-1EMBL\s0. GenBank, Swissprot (swiss), \s-1PIR\s0 and \s-1GCG\s0.
.PP
.Vb 2
\&  $seqin = Bio::SeqIO->new( '-format' => 'EMBL' , -file => 'myfile.dat');
\&  $seqout= Bio::SeqIO->new( '-format' => 'Fasta', -file => '>output.fa');
.Ve
This is the main loop which will loop progressively through sequences
in a file. Each call to seqio->\fInext_seq()\fR provides a new sequence
object from the file, reading successively.
.PP
.Vb 1
\&  while((my $seqobj = $seqio->next_seq())) {
.Ve
This print line access fields in the sequence object directly. The
seqobj->display_id is the way to access the display_id attribute
of the sequence object. The seqobj->seq method gets the actual
sequence out as string. Then you can do manipulation of this if
you want to (there are however easy ways of doing truncation,
reverse-complement and translation).
.PP
.Vb 2
\&        print "Seen sequence ",$seqobj->display_id,", start of seq ",
\&               substr($seqobj->seq,1,10),"\en";
.Ve
Bioperl has to guess the type of the sequence, being either dna,
rna or protein. The moltype attribute gives one of these three
possibilities
.PP
.Vb 1
\&        if( $seqobj->moltype eq 'dna') {
.Ve
The seqobj->revcom method provides the reverse complement of the seqobj
object as another sequence object. The \f(CW$rev\fR variable therefore is another
sequence object. For example, one could repeat the above print line
for this sequence object (putting rev in place of seqobj). In this case
we are going to output the object into the file stream we built
earlier on. 
.PP
.Vb 1
\&            $rev = $seqobj->revcom;
.Ve
When we output it, we want the id of the outputted object
to be changed to \*(L"$id.rev\*(R", ie, with .rev on the end of the name. The
following lines retrieve the id of the sequence object, add .rev
to this and then set the display_id of the rev sequence object to
this. Notice that to set the display_id attribute you just need 
call the same method (display_id) with the new value as an argument.
.PP
.Vb 3
\&            $id  = $seqobj->display_id();
\&            $id  = "$id.rev";
\&            $rev->display_id($id);
.Ve
The write_seq method on the seqout output object writes the 
\&\f(CW$rev\fR object to the filestream we built at the top of the script.
The filestream knows that it is outputting in fasta format, and
so it provides fasta output
.PP
.Vb 2
\&            $seqout->write_seq($rev);
\&         }
.Ve
This final loop loops over sequence features in the sequence
object, trying to find ones who have been tagged as 'exon'.
Features have start and end attributes and can be outputted
in \s-1GFF\s0 format, a standarised format for sequence features
.PP
.Vb 7
\&        foreach $feat ( $seqobj->top_SeqFeatures() ) {
\&           if( $feat->primary_tag eq 'exon' ) {
\&              print STDOUT "Location ",$feat->start,":",
\&                    $feat->end," GFF[",$feat->gff_string,"]\en";
\&           }
\&        }
\&   }
.Ve
.SH "Short Description of Objects."
.IX Header "Short Description of Objects."
Here is a very quick overview of the objects in bioperl
.PP
Bio::Seq \- sequence object
.PP
.Vb 1
\&   # the following methods return strings
.Ve
.Vb 7
\&   $seqobj->display_id(); # the human read-able id of the sequence
\&   $seqobj->seq();        # string of sequence
\&   $seqobj->subseq(5,10); # part of the sequence as a string
\&   $seqobj->accession_number(); # when there, the accession number
\&   $seqobj->moltype();    # one of 'dna','rna','protein'
\&   $seqobj->primary_id(); # a unique id for this sequence irregardless
\&                          # of its display_id or accession number
.Ve
.Vb 2
\&   # the following methods return an array of 
\&   # Bio::SeqFeature objects
.Ve
.Vb 3
\&   $seqobj->top_SeqFeatures # The 'top level' sequence features
\&   $seqobj->all_SeqFeatures # All sequence features, including sub
\&                            # seq features
.Ve
.Vb 2
\&   # the following methods returns new sequence objects, but
\&   # do not transfer features across
.Ve
.Vb 3
\&   $seqobj->trunc(5,10)  # truncation from 5 to 10 as new object
\&   $seqobj->revcom       # reverse complements sequence
\&   $seqobj->translate    # translation of the sequence
.Ve
Bio::SeqFeature objects:
.PP
.Vb 1
\&   # attributes which return numbers
.Ve
.Vb 3
\&   $feat->start          # start position (1 is the first base)
\&   $feat->end            # end position (2 is the second base)
\&   $feat->strand         # 1 means forward, -1 reverse, 0 not relevant
.Ve
.Vb 1
\&   # attributes which return strings
.Ve
.Vb 4
\&   $feat->primary_tag    # the main 'name' of the sequence feature,
\&                         # eg, 'exon'
\&   $feat->source_tag     # where the feature comes from, eg, 'EMBL_GenBank',
\&                         # or 'BLAST'
.Ve
.Vb 3
\&   # attributes which return sequences (these are the more restrictive
\&   # Bio::PrimarySeq objects, not Bio::Seq objects. The main difference
\&   # is that these objects do not themselves contain sequence features)
.Ve
.Vb 4
\&   $feat->seq            # the sequence between start,end on the
\&                         # correct strand of the sequence
\&   $feat->entire_seq     # the entire sequence, not necessarily on the 
\&                         # correct strand
.Ve
.Vb 1
\&   # useful methods for feature comparisons, for start/end points
.Ve
.Vb 3
\&   $feat->overlap($other)  # does feat and other overlap?
\&   $feat->contains($other) # is other completely within feat?
\&   $feat->equals($other)   # does feat and other completely agree?
.Ve
.Vb 2
\&   # sub features. For complex join() statements, the features
\&   # is one sequence feature with many sub SeqFeatures
.Ve
.Vb 1
\&   $feat->sub_SeqFeatures  # array of sub seq features
.Ve
.SH "BLAST"
.IX Header "BLAST"
\&...stuff on running \s-1BLAST\s0 and parsing results...
.SH "Database Access"
.IX Header "Database Access"
Feel free to add to this document.
