.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:50 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::SeqIO::game 3"
.TH Bio::SeqIO::game 3 "perl v5.6.0" "2001-05-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::SeqIO::game \- Parses \s-1GAME\s0 \s-1XML\s0 0.1 and higher into and out of Bio::Seq objects.  
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
To use this module you need \s-1XML:\s0:Parser, \s-1XML:\s0:Parser::PerlSAX
and \s-1XML:\s0:Writer.
.PP
Do not use this module directly.  Use it via the Bio::SeqIO class.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object can transform Bio::Seq objects to and from bioxml seq,
computation, feature and annotation dtds,versions 0.1 and higher.
These can be found at http://www.bioxml.org/dtds/current.  It does
this using the idHandler, seqHandler and featureHandler modules you
should have gotten with this one.
.PP
The idea is that any bioxml features can be turned into bioperl
annotations.  When Annotations and computations are parsed in, they
gain additional info in the bioperl SeqFeature tag attribute.  These
can be used to reconstitute a computation or annotation by the bioxml
with the bx-handler module when write_seq is called.
.PP
If you use this to write SeqFeatures that were not generated from
computations or annotations, it will output a list of bioxml features.
Some data may be lost in this step, since bioxml features just have a
span, type and description \- nothing about the anlysis performed.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
 to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 4
\&  bioperl-l@bioperl.org        - Technical bioperl discussion
\&  bioxml-dev@bioxml.org        - Technical discussion - Moderate volume
\&  bioxml-announce@bioxml.org   - General Announcements - Pretty dead
\&  http://www.bioxml.org/MailingLists/         - About the mailing lists
.Ve
.SH "AUTHOR \- Brad Marshall & Ewan Birney & Lincoln Stein"
.IX Header "AUTHOR - Brad Marshall & Ewan Birney & Lincoln Stein"
Email: bradmars@yahoo.com
       birney@sanger.ac.uk
       lstein@cshl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "_export_subfeatures"
.IX Subsection "_export_subfeatures"
.Vb 5
\& Title   : _export_subfeatures
\& Usage   : $obj->_export_subfeatures
\& Function: export all subfeatures (also in the geneprediction structure)
\& Returns : value of _export_subfeatures
\& Args    : newvalue (optional)
.Ve
.Sh "_group_subfeatures"
.IX Subsection "_group_subfeatures"
.Vb 5
\& Title   : _group_subfeatures
\& Usage   : $obj->_group_subfeatures
\& Function: Groups all subfeatures in separate feature_sets
\& Returns : value of _group_subfeatures
\& Args    : newvalue (optional)
.Ve
.Sh "_subfeature_types"
.IX Subsection "_subfeature_types"
.Vb 6
\& Title   : _subfeature_types
\& Usage   : $obj->_subfeature_types
\& Function: array of all possible subfeatures, it should be a name of a function which
\&         : returns an arrau of sub_seqfeatures when called: @array = $feature->subfeaturetyp()
\& Returns : array of _subfeature_types
\& Args    : array of subfeature types (optional)
.Ve
.Sh "_add_subfeature_type"
.IX Subsection "_add_subfeature_type"
.Vb 6
\& Title   : _add_subfeature_type
\& Usage   : $obj->_add_subfeature_type
\& Function: add one possible subfeature, it should be a name of a function which
\&         : returns an arrau of sub_seqfeatures when called: @array = $feature->subfeaturetyp()
\& Returns : 1
\& Args    : one subfeature type (optional)
.Ve
.Sh "next_seq"
.IX Subsection "next_seq"
.Vb 5
\& Title   : next_seq
\& Usage   : $seq = $stream->next_seq()
\& Function: returns the next sequence in the stream
\& Returns : Bio::Seq object
\& Args    : NONE
.Ve
.Sh "next_primary_seq"
.IX Subsection "next_primary_seq"
.Vb 5
\& Title   : next_primary_seq
\& Usage   : $seq = $stream->next_primary_seq()
\& Function: returns the next primary sequence (ie no seq_features) in the stream
\& Returns : Bio::PrimarySeq object
\& Args    : NONE
.Ve
.Sh "write_seq"
.IX Subsection "write_seq"
.Vb 5
\& Title   : write_seq
\& Usage   : Not Yet Implemented! $stream->write_seq(@seq)
\& Function: writes the $seq object into the stream
\& Returns : 1 for success and 0 for error
\& Args    : Bio::Seq object
.Ve
