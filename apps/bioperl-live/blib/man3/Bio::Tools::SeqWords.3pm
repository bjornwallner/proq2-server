.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:21 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::Tools::SeqWords 3"
.TH Bio::Tools::SeqWords 3 "perl v5.6.0" "2001-05-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::Tools::SeqWords \- Object holding n-mer statistics for one sequence
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Take a sequence object from eg, an inputstream, and creates an object 
for the purposes of holding n-mer word statistics about that sequence.
The sequence can be nucleic acid or protein, but the module is probably
most relevant for \s-1DNA\s0.  The words are counted in a non-overlapping manner,
ie. in the style of a codon table, but with any word length.
For overlapping word counts, a sequence can be 'shifted' to remove the first
character and then the count repeated.  For counts on opposite strand
(\s-1DNA/RNA\s0),
a reverse complement method should be performed, and then the count
repeated.
.PP
Creating the SeqWords object, eg:
.PP
.Vb 4
\&        my $inputstream = Bio::SeqIO->new( -file => "seqfile", -format =>
\&'Fasta');
\&        my $seqobj = $inputstream->next_seq();
\&        my $seq_word = Bio::Tools::SeqWords->new(-seq => $seqobj);
.Ve
or:
.PP
.Vb 3
\&        my $seqobj = Bio::PrimarySeq->new(-seq=>'[cut and paste a sequence here]', 
\&                                          -moltype = 'dna', -id = 'test');
\&        my $seq_word  =  Bio::Tools::SeqWords->new(-seq => $seqobj);
.Ve
obtain a hash of word counts, eg:
.PP
.Vb 1
\&        my $hash_ref = $seq_stats->count_words($word_length);
.Ve
display hash table, eg:
.PP
.Vb 5
\&        my %hash = %$hash_ref;
\&        foreach my $key(sort keys %hash)
\&        {
\&                print "\en$key\et$hash{$key}";
\&        }
.Ve
or	
.PP
.Vb 1
\&        my $hash_ref = Bio::SeqWords->count_words($seqobj,$word_length);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio:SeqWords is a featherweight object for the calculation of n-mer
word occurrences in a single sequence.  It is envisaged that the
object will be useful for construction of scripts which use n-mer word
tables as the raw material for statistical calculations; for instance,
hexamer frequency for the calculation of coding protential, or the
calculation of periodicity in repetitive \s-1DNA\s0.  Triplet frequency is
already handled by Bio::SeqStats.pm (author: Peter Schattner).  There
are a few possible applications for protein, eg: hypothesised amino
acid 7\-mers in heat shock proteins, or proteins with multiple simple
motifs.  Sometimes these protein periodicities are best seen when the
amino acid alphabet is truncated, eg Shulman alphabet.  Since there
are quite a few of these shortened alphabets, this module does not
specify any particular alphabet.
.PP
See Synopsis above for object creation code.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                 - General discussion
\&  http://bio.perl.org/MailList.html             - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.
Bug reports can be submitted via email or the web:
.PP
.Vb 2
\&  bioperl-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Derek Gatherer, in the loosest sense of the word 'author'.  The
general shape of the module is lifted directly from Peter Schattner's
SeqStats.pm module.  The central subroutine to count the words is
adapted from original code provided by Dave Shivak, in response to a
query on the bioperl mailing list.  At least 2 other people provided
alternative means (equally good but not used in the end) of performing
the same calculation.  Thanks to all for your assistance.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. 
Internal methods are usually preceded with a _
.Sh "count_words"
.IX Subsection "count_words"
.Vb 14
\& Title   : count_words
\& Usage   : $word_count = $seq_stats->count_words($word_length); 
\& or      : $word_count = $seq_stats->Bio::SeqWords->($seqobj,$word_length);
\& Function: Counts non-overlapping words within a string
\&         : any alphabet is used
\& Example : a sequence ACCGTCCGT, counted at word length 4,
\&         : will give the hash
\&         : ACCG 1, TCCG 1
\& Returns : Reference to a hash in which keys are words (any length) of the
\&alphabet
\&         : used and values are number of occurrences of the word in the
\&sequence.
\& Args    : Word length as scalar and, reference to sequence object if
\&required
.Ve
.Vb 2
\&  Throws an exception word length is not a positive integer
\&  or if word length is longer than the sequence.
.Ve
