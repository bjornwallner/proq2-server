.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jun 27 13:30:06 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bio::Root::Vector 3"
.TH Bio::Root::Vector 3 "perl v5.6.0" "2001-05-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Bio::Root::Vector \- Interface for managing linked lists of Perl5 objects.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Sh "Object Creation"
.IX Subsection "Object Creation"
\&\fBAt present, Vector objects cannot be instantiated.\fR This
package is currently designed to be inherited along with another class
that provides a constructor (e.g., \fBBio::Root::Object.pm\fR).
The Vector provides a set of methods that can then be used for managing
sets of objects.
.PP
See the USAGE manpage.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
This module is included with the central Bioperl distribution:
.PP
.Vb 2
\&   http://bio.perl.org/Core/Latest
\&   ftp://bio.perl.org/pub/DIST
.Ve
Follow the installation instructions included in the \s-1README\s0 file.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Root::Vector.pm  provides an interface for creating and manipulating
dynamic sets (linked lists) of Perl5 objects. This is an abstract class (ie.,
there is no constructor) and as such is expected to be inherited along with
some other class (see note above).
.PP
Vectors are handy when, for example, an object may contain one or more
other objects of a certain class. The container object knows only
that is has at least one such object; the multiplex nature of the contained
object is managed by the contained object via its Vector interface.
The methods for adding, removing, counting, listing, and sorting all objects
are bundled together in Vector.pm.
.PP
Thus, the current Bio::Root::Vector class is somewhat of a cross between an
interator and a composite design pattern. At present, a number of classes
utilize Bio::Root::Vector's composite-like behavior to implement a composite
pattern (Bio::SeqManager.pm, for example).
This is not necessarily ideal and is expected to change.
.SH "USAGE"
.IX Header "USAGE"
For a usage demo of Bio::Root::Vector.pm, see:
.PP
.Vb 1
\&    http://bio.perl.org/Core/Examples/Root_object/Vector
.Ve
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Bio::Root::Vector.pm does not directly inherit from \fBBio::Root::Object.pm\fR but
creates an manager object which does.
.SH "BUGS/FEATURES"
.IX Header "BUGS/FEATURES"
By default, all Vectors are doubly-linked lists. This relieves one from
the burden of worrying about whether a given Vector is single- or doubly-linked.
However, when generating lots of Vectors or extremely large vectors, memory
becomes an issue. In particular, signaling the \s-1GC\s0 to free the memory for
an object when you want to remove it. \fBUntil this memory issue is resolved,
the use of Vector.pm is not recommended for large projects.\fR
.PP
Although it is not required, all objects within a vector are expected
to derive from the same class (package). Support for heterogeneous
Vectors has not been explicitly added (but they should work fine, as long
as you know what you're doing).
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other Bioperl modules.
Send your comments and suggestions preferably to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org             - General discussion
\&  http://bioperl.org/MailList.shtml - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track the bugs and
their resolution. Bug reports can be submitted via email or the web:
.PP
.Vb 2
\&    bioperl-bugs@bio.perl.org
\&    http://bio.perl.org/bioperl-bugs/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve A. Chervitz, sac@genome.stanford.edu
.PP
See the the FEEDBACK manpage section for where to send bug reports and comments.
.SH "VERSION"
.IX Header "VERSION"
Bio::Root::Vector.pm, 0.04
.SH "TODO"
.IX Header "TODO"
.Ip "\(bu (Maybe) create an container class version of this module" 4
.IX Item "(Maybe) create an container class version of this module"
to permit Vectors to be instantiated. Thus, instead of inherited
from both Object.pm and Vector.pm, you could create a Vector.pm object.
.Ip "\(bu Improve documentation." 4
.IX Item "Improve documentation."
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 3
\&  Bio::Root::Object.pm    - Core object
\&  Bio::Root::Err.pm       - Error/Exception object
\&  Bio::Root::Global.pm    - Manages global variables/constants
.Ve
.Vb 2
\&  http://bio.perl.org/Projects/modules.html  - Online module documentation
\&  http://bio.perl.org/                       - Bioperl Project Homepage
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This module was developed under the auspices of the Saccharomyces Genome
Database:
    http://genome-www.stanford.edu/Saccharomyces
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1996\-98 Steve A. Chervitz. All Rights Reserved.
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "APPENDIX"
.IX Header "APPENDIX"
Methods beginning with a leading underscore are considered private
and are intended for internal use by this module. They are
\&\fBnot\fR considered part of the public interface and are described here
for documentation purposes only.
.Sh "set_rank"
.IX Subsection "set_rank"
.Vb 9
\& Purpose  : To set an object's rank to an arbitrary numeric
\&          : value to be used for sorting the objects of the Vector.
\& Usage    : $self->set_rank(-RANK    =>numeric_ranking_data,
\&          :                 -RANK_BY =>ranking_criterion_string);
\&          : or without the named parameters as (rank, rank_by).
\& Throws   : warning (if rank is set without also setting RANK_BY)
\& Comments : It is redundant for every object to store RANK_BY data.
\&          : For this reason, the RANK_BY data is stored with the master
\&          : object associated with the vector.
.Ve
See Also  : the rank manpage(), the rank_by manpage()
.Sh "clone_vector"
.IX Subsection "clone_vector"
.Vb 7
\& Purpose  : Call this method to clone the whole vector.
\&          : NOT calling this method will extract the vector element.
\& Usage    : $self->clone_vector();
\& Throws   : Exception if argument is not an object reference.
\& Comments : This method is usually called from within a module's
\&          : _set_clone() method for modules that inherit from
\&          : Bio::Root::Vector.pm.
.Ve
.Sh "prev"
.IX Subsection "prev"
.Vb 3
\& Purpose  : Returns the previous object in the Vector or undef
\&          : if on first object.
\& Usage    : $self->prev
.Ve
.Sh "next"
.IX Subsection "next"
.Vb 3
\& Purpose  : Returns the next object in the Vector or undef
\&          : if on last object.
\& Usage    : $self->next
.Ve
.Sh "first"
.IX Subsection "first"
.Vb 3
\& Purpose  : Returns the first object in the Vector or $self
\&          : if Vector size = 1.
\& Usage    : $self->first
.Ve
.Sh "last"
.IX Subsection "last"
.Vb 3
\& Purpose  : Returns the last object in the Vector or
\&          : $self if Vector size = 1.
\& Usage    : $self->last
.Ve
.Sh "rank"
.IX Subsection "rank"
.Vb 3
\& Purpose  : Returns the rank of the current object or 1
\&          : if rank is not defined.
\& Usage    : $self->rank
.Ve
See Also  : the set_rank manpage()
.Sh "rank_by"
.IX Subsection "rank_by"
.Vb 3
\& Purpose  : Returns the ranking criterion or the string 'order of addition'
\&          : if rankBy has not been explicitly set.
\& Usage    : $self->rank_by
.Ve
See Also  : the set_rank manpage()
.Sh "size"
.IX Subsection "size"
.Vb 2
\& Purpose  : Returns the number of objects currently in the Vector.
\& Usage    : $self->size
.Ve
.Sh "master"
.IX Subsection "master"
.Vb 3
\& Purpose  : Returns the master object associated with the Vector.
\&          : (should probably be a private method).
\& Usage    : $self->master
.Ve
.Sh "is_first"
.IX Subsection "is_first"
.Vb 2
\& Purpose  : Test whether the current object is the first in the Vector.
\& Usage    : $self->is_first
.Ve
.Sh "is_last"
.IX Subsection "is_last"
.Vb 2
\& Purpose  : Test whether the current object is the last in the Vector.
\& Usage    : $self->is_last
.Ve
.Sh "get"
.IX Subsection "get"
.Vb 4
\& Purpose  : Retrives an object from the Vector given its name.
\&          : Returns undef if the object cannot be found.
\& Usage    : $self->get(object_name)
\& Examples : $self->get($obj->name)
.Ve
See Also  : the list manpage()
.Sh "add"
.IX Subsection "add"
.Vb 2
\& Purpose  : Add an object to the end of a Vector.
\& Usage    : $self->add(object_reference)
.Ve
See also  : the insert manpage(), the remove manpage()
.Sh "remove"
.IX Subsection "remove"
.Vb 12
\& Purpose  : Remove the current object from the Vector.
\& Usage    : $self->remove([-RET=>'first'|'last'|'next'|'prev'], [-UPDATE => 0|1])
\& Returns  : The first, last, next, or previous object in the Vector
\&          : depending on the value of the -RET parameter.
\&          : Default = next.
\& Argument : Named parameters: (TAGS CAN BE ALL UPPER OR ALL LOWER CASE)
\&          :    -RET    => string: 'first', 'last', 'prev' 'next'
\&          :               THis indicates the object to be returned.
\&          :    -UPDATE => boolean, if non-zero all objects in the vector
\&          :               will be re-ranked.
\& Comments : The -UPDATE parameter should be set to true to force a re-updating
\&          : of the rank data for each object. (default = 0, no update).
.Ve
See Also  : the add manpage(), the insert manpage(), the shift manpage(), the chop manpage()
.Sh "remove_all"
.IX Subsection "remove_all"
.Vb 2
\& Purpose  : Remove all objects currently in the Vector.
\& Usage    : $self->remove_all
.Ve
See Also  : the remove manpage(), the shift manpage(), the chop manpage()
.Sh "shift"
.IX Subsection "shift"
.Vb 4
\& Purpose  : Remove the first object from the Vector.
\&          : This is a wrapper for remove().
\& Usage    : $self->shift([-RET=>'first'|'last'|'next'|'prev'])
\& Returns  : The object returned by remove().
.Ve
See Also  : the remove manpage(), the chop manpage()
.Sh "chop"
.IX Subsection "chop"
.Vb 4
\& Purpose  : Remove the last object from the Vector.
\&          : This is a wrapper for remove().
\& Usage    : $self->chop([-RET=>'first'|'last'|'next'|'prev'])
\& Returns  : The object returned by remove().
.Ve
See Also  : the remove manpage(), the shift manpage()
.Sh "insert"
.IX Subsection "insert"
.Vb 6
\& Purpose  : Insert a new object into the vector relative to the current object.
\& Usage    : $self->insert(object_ref, ['before'|'after'])
\& Examples : $self->insert($obj)  # Default insert after $self
\&          : $self->insert($obj,'before')
\& Returns  : The new number of objects in the vector (int).
\& Throws   : exception if the first argument is not a reference.
.Ve
See Also  : the add manpage(), the remove manpage()
.Sh "list"
.IX Subsection "list"
.Vb 4
\& Purpose  : Returns objects in the Vector as an array or array slice.
\& Usage    : $self->list([starting_object|'first'] [,ending_object|'last'])
\& Examples : $self->list
\&          : $self->list('first',$self->prev)
.Ve
See Also  : the get manpage()
.Sh "sort"
.IX Subsection "sort"
.Vb 8
\& Purpose  : Sort the objects in the Vector.
\& Usage    : $self->sort(['rank'|'name'], [reverse])
\& Returns  : The last object of the sorted Vector.
\& Argument : First argument can be 'name' or 'rank' to sort on
\&          : the object's name or rank data member, respectively.
\&          : If reverse is non-zero, sort will be in reverse order.
\& Example  : $self->sort()   #  Default sort by rank, not reverse.
\&          : $self->sort('name','reverse')
.Ve
.Sh "valid_any"
.IX Subsection "valid_any"
.Vb 5
\& Purpose  : Determine if at least one object in the Vector is valid.
\& Usage    : $self->valid_any
\& Status   : Deprecated.
\& Comments : A non-valid object should throw an exception that must be
\&          : be caught an dealt with on the spot.
.Ve
See Also  : \fB\f(BIBio::Root::Object::valid()\fB\fR
.Sh "valid_all"
.IX Subsection "valid_all"
.Vb 4
\& Purpose  : Determine if all objects in the Vector are valid.
\& Usage    : $self->valid_all
\& Comments : A non-valid object should throw an exception that must be
\&          : be caught an dealt with on the spot.
.Ve
See Also  : \fB\f(BIBio::Root::Object::valid()\fB\fR
.SH "FOR DEVELOPERS ONLY"
.IX Header "FOR DEVELOPERS ONLY"
.Sh "Data Members"
.IX Subsection "Data Members"
Information about the various data members of this module is provided for those
wishing to modify or understand the code. Two things to bear in mind:
.Ip "1 Do \s-1NOT\s0 rely on these in any code outside of this module." 4
.IX Item "1 Do NOT rely on these in any code outside of this module."
All data members are prefixed with an underscore to signify that they are private.
Always use accessor methods. If the accessor doesn't exist or is inadequate,
create or modify an accessor (and let me know, too!).
.Ip "2 This documentation may be incomplete and out of date." 4
.IX Item "2 This documentation may be incomplete and out of date."
It is easy for this documentation to become obsolete as this module is still evolving.
Always double check this info and search for members not described here.
.PP
Bio::Root::Vector.pm objects currently cannot be instantiated. Vector.pm must be inherited
along with Bio::Root::Object.pm (or an object that provides a constructor).
Vector.pm defines the following fields:
.PP
.Vb 3
\& FIELD          VALUE
\& ------------------------------------------------------------------------
\&  _prev         Reference to the previous object in the Vector.
.Ve
.Vb 1
\&  _next         Reference to the next object in the Vector.
.Ve
.Vb 2
\&  _rank         Rank relative to other objects in the Vector.
\&                Default rank = chronological order of addition to the Vector.
.Ve
.Vb 4
\&  _master       A reference to an Bio::Root::Object that acts as a manager for
\&                the given Vector. There is only one master per Vector.
\&                A master object is only needed when the Vector size is >1.
\&                The master object manages the following Vector data:
.Ve
.Vb 9
\&                _first  - Reference to the first object in the Vector.
\&                _last   - Reference to the last object in the Vector.
\&                _size   - Total number of objects in the Vector.
\&                _rankBy - Criteria used to rank the object.
\&                         Default: chronological order of addition.
\&                _index  - Hash reference for quick access to any object
\&                         based on its name.
\&                Bio::Root::Object{'_err'} - Holds any errors affecting the
\&                                     Vector as a whole.
.Ve
