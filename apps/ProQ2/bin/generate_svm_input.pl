#!/usr/bin/perl  

require '/tmp/proq2-server/apps/ProQ2/bin/stat.pl';

my @aa_order = split(//,'ACDEFGHIKLMNPQRSTVWY');my @altschul_mapping = (0,4,3,6,13,7,8,9,11,10,12,2,14,5,1,15,16,19,17,18);
if(scalar(@ARGV)>0 && scalar(@ARGV)%2==1)
{
    print "All switches needs to be followed by a number!\n";
    exit;

}
if(scalar(@ARGV)==0)
{
    usage();
    exit;
}


%param=@ARGV;

if(not(defined($param{-i})))
{
    print "\tERROR: -i <input folder> not defined!\n";
    usage();
    exit;
}
if(not(defined($param{-o})))
{
    print "ERROR: -o <output folder> not defined!\n";
    usage();
    exit;
}
$dir=$param{-i};
$dir_is_file=0;
$dir_is_file=1 if(-f $dir);
$outdir=$param{-o};
#don't want these in the subfolder name;
delete($param{-i});
delete($param{-o});
#$dir=$ARGV[0];
#$outdir=$ARGV[1];
$noprefix=0;
if($param{-noprefix}) { #this will make no prefix

    $noprefix=1;
    delete($param{-noprefix});
}
$classify=0;
if($param{-classify}) { #this will ignore the Sscore...

    $classify=1;
    delete($param{-classify});
}

$casp7_test=0;
if($param{-casp7_test}) {
    $casp7_test=1;
    delete($param{-casp7_test});
}

#set default values...
if(not(defined($param{-ss_content})))
{
    $param{-ss_content}=0;
}
if(not(defined($param{-atom})))
{
    $param{-atom}=0;
}
if(not(defined($param{-res})))
{
    $param{-res}=0;
}
if(not(defined($param{-restypes})))
{
    $param{-restypes}=6;
}
if(not(defined($param{-rc})))
{
    $param{-rc}=5;
}
if(not(defined($param{-ac})))
{
    $param{-ac}=5;
}
if(not(defined($param{-pwin})))
{
    $param{-pwin}=9;
}
if(not(defined($param{-surf25})))
{
    $param{-surf25}=0;
}
if(not(defined($param{-surf50})))
{
    $param{-surf50}=0;
}
if(not(defined($param{-surf75})))
{
    $param{-surf75}=0;
}
if(not(defined($param{-surf100})))
{
    $param{-surf100}=0;
}
#@training_ids=("ATOM","RES","SURF25","SURF50","SURF75","SURF100"); #SS is now read separately
@training_ids=();
@index=();

if($param{-atom}) {
    push(@training_ids,"ATOM");
}
if($param{-res}) {
    push(@training_ids,"RES");
}
if($param{-surf25}) {
    push(@training_ids,"SURF25");
}
if($param{-surf50}) {
    push(@training_ids,"SURF50");
}
if($param{-surf75}) {
    push(@training_ids,"SURF75");
}
if($param{-surf100}) {
    push(@training_ids,"SURF100");
}





if(not(defined($param{-Sscore})))
{
    $param{-Sscore}=3;
}
$Sscore_cutoff=$param{-Sscore};
if(not(defined($param{-n})))
{
    $param{-n}=10;
}
delete($param{-n});
if(not(defined($param{-ss})))
{
    $param{-ss}=0;
}
if(not(defined($param{-stride})))
{
    $param{-stride}=0;
}

if(not(defined($param{-entropy})))
{
    $param{-entropy}=0;
}
if(not(defined($param{-shannon})))
{
    $param{-shannon}=0;
}
if(not(defined($param{-zpred})))
{
    $param{-zpred}=0; #predicted Zcoord
}
if(not(defined($param{-z})))
{
    $param{-z}=0; #Zcoord
}
if(not(defined($param{-z_sc})))
{
    $param{-z_sc}=0; #predicted vs. true Zcoord score.
}

if(not(defined($param{-prsa})))
{
    $param{-prsa}=0; #predicted surface
}
if(not(defined($param{-rsa_sc})))
{
    $param{-rsa_sc}=0; #predicted vs. true surface score.
}
if(not(defined($param{-grsa_sc})))
{
    $param{-grsa_sc}=0; #GLOBAL predicted vs. true surface score.
}
if(not(defined($param{-ss_sc})))
{
    $param{-ss_sc}=0; #predicted vs. true ss score.
}
if(not(defined($param{-gss_sc})))
{
    $param{-gss_sc}=0; #GLOBAL predicted vs. true ss score.
}
if(not(defined($param{-profile})))
{
    $param{-profile}=0;
}
if(not(defined($param{-rsa})))
{
    $param{-rsa}=0;
}
if(not(defined($param{-topology})))
{
    $param{-topology}=0;
}
if(not(defined($param{-pw})))
{
    $param{-pw}=0;
}
if(not(defined($param{-termini})))
{
    $param{-termini}=0;
}
#if(not(defined($param{-termini2})))
#{
#    $param{-termini2}=0;
#}


#build up uniq subfolder;
$subfolder="svmdata";
foreach my $key(sort(keys(%param)))
{
    next if($key eq "-shannon" ||
	    $key eq "-ss_content");
    print "$key $param{$key}\n";
    $subfolder.="$key$param{$key}";
}
print $subfolder."\n";
#exit;
$outdir="$outdir/$subfolder";
#exit;



#$use_entropy=0;
#if(defined($ARGV[2])) {
#    $Sscore_cutoff=$ARGV[2];
#}

if(!-e $outdir)
{
    `mkdir -p $outdir`;
#	`chdir $outdir`;
}


#The following will divide the set into 5 subset based on the cluster generated by blastclust (currently 20% seq id and 50% overlap)
$clust_no=1;
#$blastclustfile="$dir/pdb.fasta.seq.30";
$rosetta=0;
$rosetta=1 if($dir=~/jumplib/);
$relax=0;
$relax=1 if($dir=~/decoys/);
$casp7=1 if($dir=~/casp7/);
$blastclustfile="$dir/pdb.fasta.seq.-S20-L0.5";
$blastclustfile="$dir/pdb.fasta.seq.-S20-L0.2" if($casp7);

$filelist="$dir/pdb.fasta.seq.-S20-L0.5.out.5";
#$filelist="$dir/pdb.fasta.seq.-S20-L0.5.out.5" if($dir=~/casp7/);


%id2set=();
%id2clust=();
%set2id=();
if(!$dir_is_file && !$rosetta && !$relax && !$casp7_test) {
    %list=();
    if(not($casp7)) {
	open(FILE,$filelist);
	while(<FILE>) {
	    s/\.pdb//g;
	    s/\.fixed//g;
	    @temp=split(/\s+/);
	    $list{$temp[2]}=1;
	}
    }
    $set_number=1;
    $membrane2=0;
    $membrane2=1 if($dir=~/membrane2/);
#@m=("profprof","profseq","seqprof","seqseq");
    @m=("profprof","seqprof","seqseq");
    open(CLUST,$blastclustfile);
    while(<CLUST>)
    {
	if(/\.pdb/ || /TS\d/) {
	    s/\.pdb//g;
	    s/\.fixed//g;
	    my @ids=split(/\s+/);
#	my @ids=grep(/\.global/,@ids_all);
#	    @{$set2id{$set_number}}=() if(not(defined(@{$set2id{$set_number}})));
#	@{$set2id{$set_number}}=(@{$set2id{$set_number}},@ids);
	    $c=0;
	    foreach $id(@ids) {
		next if(not($casp7) && not(defined($list{$id})));
		print $id."\n";
		push(@{$set2id{$set_number}},$id);
		$id2set{$id}=$set_number;
		$id2clust{$id}=$clust_no;
		if($membrane2) {
		    @temp2=split(/\./,$id);
		    foreach $m(@m) {
			$id="$temp2[0].$m.B99990001";
			print $id."\n";
			push(@{$set2id{$set_number}},$id);
			$id2set{$id}=$set_number;
			$id2clust{$id}=$clust_no;
		    }
		    
		}
		
		$c++;
		
#	    last if($c>=$param{-n});
	    }
	    $set_number++;
	    $set_number=1 if($set_number>5);
	    $clust_no++;
	}

    }

    foreach $n(sort {$a<=>$b}(keys(%set2id)))
    {
	$n2=scalar(@{$set2id{$n}});
	print "set no count: $n $n2\n";
	open(SET,">$outdir/set$n.id");
	print SET join("\n",@{$set2id{$n}});
	close(SET);
	

	
    }
}

#exit;
#exit if($casp7);


#RESIDUE NUMBER: 2         
#ATOM: 0.008734 0.043668 0.030568 0.034934 0.034934 0.056769 0.000000 0.000000 0.000000 0.000000 0.000000 0.021834 0.000000 0.008734 0.056769 0.017467 0.026201 0.017467 0.000000 0.000000 0.000000 0.000000 0.000000 0.021834 0.000000 0.017467 0.039301 0.065502 0.082969 0.000000 0.000000 0.000000 0.000000 0.000000 0.021834 0.000000 0.004367 0.026201 0.030568 0.000000 0.000000 0.000000 0.000000 0.000000 0.021834 0.000000 0.043668 0.104803 0.000000 0.000000 0.013100 0.000000 0.008734 0.026201 0.000000 0.065502 0.000000 0.000000 0.013100 0.000000 0.008734 0.017467 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.008734 0.000000 0.000000 
#RES: 0.000000 0.000000 0.052632 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.105263 0.000000 0.105263 0.000000 0.210526 0.263158 0.000000 0.210526 0.052632 0.000000 
#SURF25: 0.000000 0.000000 0.166667 0.166667 0.166667 0.000000 
#SURF50: 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 
#SURF75: 0.000000 0.000000 0.000000 0.166667 0.166667 0.000000 
#SURF100: 0.000000 0.000000 0.000000 0.166667 0.000000 0.000000 
#SS: 0.631000
#PROQRES: 0.845364
#TER

$noprof="-noprof";
$noprof="" if($param{-pw});
my $proqres_flags="-rc $param{-rc} -ac $param{-ac} -w $param{-pwin} -t $param{-restypes} $noprof";
my $proqres_name=$proqres_flags;
$proqres_name=~s/\s+//g;

if($dir_is_file) {
    @files=($dir);
    @temp=split(/\//,$dir);
    $dir=$dir.".dir"; #join('/',@temp[0..$#temp-1]);
    $file_base=$temp[$#temp];
    $prefix="";
    if(!$noprefix) {
	$prefix=$temp[$#temp-1];
    }
	      
} else {
    opendir(DIR,$dir);
    @files=readdir(DIR);
}
if($rosetta) {
    $target_name=substr($dir,0,4);

}
if($relax) {
#models/1e12A-1m0lA.global.B99990001/
    $target_name=substr($dir,7,28);
 #   print $target_name."\n";
  #  exit;
}


my %casp7_setid=();
if($casp7_test) {
    open(FILE,"/afs/pdc.kth.se/home/b/bjornw/.vol/bjornw27/casp7_selected.setid");
    while(<FILE>) {
	chomp;
	my ($target,$id)=split(/\s+/);
#	print "$target $id\n";
	$casp7_setid{$target}=$id;
    }

}


foreach $file(@files)
{
#    print $file."\n";

	if($file=~/\.pdb\.fixed$/ ||
	    $file=~/TS\d$/ ||
	    $dir_is_file ||
	   ($rosetta && $file=~/\.pdb$/) ||
	   ($relax && $file=~/\.pdb$/)) {
	    $id=$file;
	    @temp=split(/\-/,$file);
	    my $target_id=$temp[0];
	    if($casp7) {
		@temp=split(/\./,$file);
		$target_id=$temp[0];
	    }
	    if($rosetta || $relax) {
		$target_id=$file;
		
	    }
	    if($casp7_test) {
	
		
		if($dir=~/(T0\d\d\d)/) {
		    if(($file=~/^server\-/) || 
		       ($file=~/^SBC0/) || 
		       ($file=~/^SBC_no_Zhang/) ||
		       ($file=~/ProQ/) ||
		       ($file=~/QA_/) ||
		       ($file=~/FANG_/) ||
		       ($file=~/BestPcons/) ||
		       ($file=~/Pmod6_wo_rob/) ||
		       ($file=~/Pcons1/) ||
		       ($file=~/scwrl/)) {
			next;
		    }

		    $target_id=$1;
		    if(not(defined($casp7_setid{$target_id}))) {
			print "TARGET ID $target_id not defined in casp7_selected.setid\n";
			next;
		    }
		} 
		else 
		{
		    next;
		}
		
	    }
	    
	    if(!$dir_is_file && !$rosetta && !$relax && !$casp7_test) {
		$id=~s/\.pdb\.fixed$//g;
		next if(not(defined($id2set{$id})));
	    }
	    #print "id:$id\n";
	    if($classify) {
		    $proqoutfile="$file.proqres2";
#		    print STDERR "PROQ: $proqoutfile\n";
	    }else {
		$proqoutfile_dir="$dir/proqres/proqres-$proqres_name/";
		`mkdir -p $proqoutfile_dir`;
		if($dir_is_file) {
		    $proqoutfile="$proqoutfile_dir/$file_base";
		} else {
		    $proqoutfile="$proqoutfile_dir/$file";
		}
	    }
	    if(!$casp7) {
		#$Sscorefile="$dir/$file.S.gz";
		#if($Sscore_cutoff != 5)
		#{
		#    $Sscorefile="$dir/S/$file.S.$Sscore_cutoff.gz";
		#}
#update to new S-score calculations....		$Sscorefile="$dir/S/$file.S.$Sscore_cutoff.gz";
		$Sscorefile="$dir/S_new/$file.S.$Sscore_cutoff.gz";
		$Sscorefile="$dir/S/$file.S.gz" if($rosetta);
		$Sscorefile="$dir/S/$file.S.gz" if($relax);
		if($dir_is_file) {
		    $Sscorefile="$file.S.gz";
		    $Sscorefile="$file.S.$Sscore_cutoff.gz" if(!-e $Sscorefile);
		    $Sscorefile="$file.S.$Sscore_cutoff" if(!-e $Sscorefile);
			
		} 
		$Sscorefile="$dir/$file.S.$Sscore_cutoff.gz" if(!-e $Sscorefile);
		$Sscorefile="$dir/$file.S.$Sscore_cutoff" if(!-e $Sscorefile);
		
	    }else {

#		$Sscorefile="$dir/S/$file.S.$Sscore_cutoff.gz";
		$Sscorefile="$dir/S_new/$file.S.$Sscore_cutoff.gz";
		$Sscorefile="$dir/$file.S.$Sscore_cutoff.gz" if(!-e $Sscorefile);
		$Sscorefile="$dir/$file.S.$Sscore_cutoff" if(!-e $Sscorefile);
	    }
	    if($dir_is_file) {
		$pdbfile=$file;
	    } else {
		$pdbfile="$dir/$file";
	    }
	    $ss2="$pdbfile.ss2";
	    $stride="$pdbfile.stride";
	    $rsa="$pdbfile.rsa";
	    $prof="$pdbfile.psi";
	    $prof_mtx="$pdbfile.mtx";
	    $prof="$pdbfile.seq.psi" if(!-e $prof);
	    $prof_mtx="$pdbfile.seq.mtx" if(!-e $prof_mtx);

	    $topology_file="$pdbfile.topcons";
	    $co_file="$pdbfile.co";
	    $zpred_file="$pdbfile.zpred";
	    $z_file="$pdbfile.Z";
	    $mprap_file="$pdbfile.mpSA";
	    $prsa_file="$pdbfile.acc";
	    
	    if($rosetta) {
		my $path="/Users/bjornw/Research/new.jumplib.runs/natives/";
		$ss2="$path/$target_name.pdb.ss2";
		$stride="$dir/stride/$file.stride";
		$rsa="$dir/rsa/$file.rsa";
		`gunzip -f $stride.gz` if(-e "$stride.gz");
		`gunzip -f $rsa.gz` if(-e "$rsa.gz");

		$prof="$path/$target_name.pdb.psi";
		$prof_mtx="$path/$target_name.pdb.mtx";
		
		$topology_file="$path/$target_name.pdb.topcons";
	#	$co_file="$pdbfile.co";
		$zpred_file="$path/$target_name.pdb.zpred";
		$z_file="$dir/Z/$file.Zcoord.gz";
		$mprap_file="$path/$target_name.pdb.mpSA";
	    }
	    if($relax) {
		my $path="/home/bjornw/afs/.vol/bjornw27/membrane/";
		$ss2="$path/$target_name.pdb.fixed.ss2";
		$stride="$dir/stride/$file.stride";
		$rsa="$dir/rsa/$file.rsa";
		`gunzip -f $stride.gz` if(-e "$stride.gz");
		`gunzip -f $rsa.gz` if(-e "$rsa.gz");

		$prof="$path/$target_name.pdb.fixed.psi";
		$prof_mtx="$path/$target_name.pdb.fixed.mtx";
		
		$topology_file="$path/$target_name.pdb.fixed.topcons";
	#	$co_file="$pdbfile.co";
		$zpred_file="$path/$target_name.pdb.fixed.zpred";
		$z_file="$dir/Z/$file.Zcoord.gz";
		$mprap_file="$path/$target_name.pdb.fixed.mpSA";
	    }



	    @Sscore=();
	    @Sscore_norm=();
	    @entropy=();
	    @shannon=();
	    @profile=();
	    @profile_mtx=();
	    @rsa=();
	    @prsa=();

	    @ss=();
	    @helix=();
	    @sheet=();
	    @coil=();
	    @topology=();
	    @co=();
	    @co_count=();
	    @zpred=();
	    @Z=();
	    next if($casp7_test && !-e $stride || !-e $ss2 || !-e $rsa);
	    if(!-e "$proqoutfile.gz") {
		`touch $proqoutfile.gz`;
#		`touch $proqoutfile`;
		if(!-e $rsa) {
		    next if($casp7_test);
		    print "rsa: $rsa does not exist! $target_id\n"; 
		    print "~/modules/naccess $pdbfile\n";
		    `rm -fr tmp$$.*`;
		    `grep ATOM $pdbfile > tmp$$.pdb`;
		    `~/modules/naccess tmp$$.pdb`;
		    `mv tmp$$.rsa $rsa`;
		    `rm -fr tmp$$*`;
		    #next;
		}
		if(!-e $stride) {
		    next if($casp7_test);
		    print "stride: $stride does not exist!\n"; 
		    `/afs/pdc.kth.se/home/a/arnee/MODULES/scientific/stride/linux/bin/stride $pdbfile > $stride`;
		  #  next;
		}
		if(!-e $ss2 || -s $ss2 == 0) {
		    print "psipred: $ss2 does not exist!\n";
		    next;
		}
		if(!-e $prof || -s $prof == 0) {
		    print "profile: $prof does not exist!\n";
		    next;
		}
		#`touch $proqoutfile`;
		print "Running ProQres on $file to $proqoutfile ....\n";
	
		$proqbinary="ulimit -s unlimited;export PROQRESDIR=/afs/pdc.kth.se/home/b/bjornw/CASP9/apps/ProQres/weights; /afs/pdc.kth.se/home/b/bjornw/source/c/pdb/ProQres/PROQRES/bin/ProQres64";
#		$proqbinary="/afs/pdc.kth.se/home/b/bjornw/source/c/pdb/ProQres/PROQRES/bin/ProQres.Darwin" if(-e "/Users/");
		$proqbinary="/afs/pdc.kth.se/home/b/bjornw/CASP9/Apps/ProQres/bin/ProQres" if(-e "/Users/");
		print "$proqbinary -pdb $pdbfile -surf $rsa -stride $stride -psipred $ss2 -prof $prof $proqres_flags -output_input\n";
		`$proqbinary -pdb $pdbfile -surf $rsa -stride $stride -psipred $ss2 -prof $prof $proqres_flags -output_input > /scratch/tmp2.$$`;
		
		`gzip -f /scratch/tmp2.$$`;
		`mv /scratch/tmp2.$$.gz $proqoutfile.gz`;
		`rm -fr /scratch/tmp2.$$.gz`;
		#next;
		
	    }
	    $length=`zgrep -c '^TER' $proqoutfile.gz`;
	    chomp($length);

	    my ($seq_ss,$ss_pred,$helix,$sheet,$coil)=read_in_psipred2($ss2);
	   
	    @helix=@{$helix};
	    @sheet=@{$sheet};
	    @coil=@{$coil}; 
	    @ss_pred=split(//,$ss_pred);
	    ($seq_stride,$ss)=read_in_stride($stride);
	    @ss=split(//,$ss);
	    if(-e $topology_file) {
		next if(-s $topology_file < 1000);
		my ($topo_seq,$topo)=parse_topcons($topology_file);
		$topo=~s/iMi/iii/g;
		$topo=~s/MiM/MMM/g;
		@topology=split(//,$topo);
		if(scalar(@topology) != length($seq_stride)) {
		    
		    print "$topology_file\n";
		    print "$seq_stride\n$topo\n$topo_seq\n";
		    print scalar(@topology);
		    print " ";
		    print length($seq_stride);
		    print "\n";
		}
		#$next;
		
	    }
	    if(-e $zpred_file) {
		@zpred=parse_Zpred($zpred_file);
	    }
	    if(-e $z_file) {
		@z=parse_Z($z_file);
	    }
	    #next;
#	    print scalar(@helix);
#	    print "\n";
#	    print scalar(@ss);
#	    print "\n";
#		    exit;
#	    foreach $h(@helix) {
#		print $h."\n";
#	    }
#	    exit;

	    if($classify) {
		print "Classifying I don't know the Score....\n";
		for(my $i=1;$i<=$length;$i++) {

		    push(@Sscore,0);
		    push(@Sscore_norm,0);
		}
	    }
	    elsif(-e $Sscorefile)
	    {
		print "Using $Sscorefile for Sscore\n";
		if($Sscorefile=~/\.gz$/) {
		    open(SCORE,"gunzip -c $Sscorefile |");
		} else
		{
		    open(SCORE,"$Sscorefile");
		}
		while(<SCORE>) 
		{
		    if(/^[\d,-]+\s[A-Z]\s([\d\.]+)/)
		    {
			#print;
			#print $1;
			#print "\n";
			push(@Sscore,$1);
			push(@Sscore_norm,2*$1-1);
		    }

		}
		close(SCORE);
		
	    } 
	    else
	    {
		print "$Sscorefile does not exist, what can I do when you don't give me the data....?\n";
		next;
	    }
#	    $mean_Sscore=mean(@Sscore);
#	    $std_Sscore=std(@Sscore);
	    if(-e $prof) {
		open(PROF,"$prof");
		while(<PROF>)
		{
		    if(/(\d+)\s[A-Z]\s/)
		    {
			@temp=split(/\s+/);

			
			@tmp_log_odds=@temp[3..22];
			$entropy=$temp[43];
			#print $_;
			#print join(" ",@log_odds);
			#print "\n";
			for(my $i=0;$i<20;$i++) {
#			    $profile_mtx[$i]=1/(1+exp($tmp_log_odds[$altschul_mapping[$i]]/100));
			    $profile[$i]=1/(1+exp(-$tmp_log_odds[$altschul_mapping[$i]]));
#			    print "$aa_order[$i] $profile_mtx[$i] $profile[$i]\n";
						
			}
			#foreach my $a(@profile) {
			    #$a=1/(1+exp(-$a));
			#}
			#print join(" ",@log_odds);
			#print "\n";
#			print "$1 $entropy\n";
			push(@entropy,$entropy);
		    }
		}
		#exit;
		close(PROF);
	    }
	    else
	    {
		print "$prof does not exist cannot read entropy data...\n";
	    }
	    
	    if(-e $prof_mtx) {
		
		open(PROF,"$prof_mtx");
		while(<PROF>)
		{
		    if(/-32768/)
		    {
			@temp=split(/\s+/);
#-32768  -264  -32768  
#-260  -507  -433  -106  -514  -439  189  -393  508  62  -485  -429  -366  -374  -379  -235  196  -328  -100  -249  -32768  -32768  -395  -32768  -32768
			my @tmp_log_odds=@temp[1,3..20,22];
			#print $_;
			#print join(" ",@tmp_log_odds);
			#print "\n";
			#print scalar(@tmp_log_odds);
			for(my $i=0;$i<20;$i++) {
#			    $profile_mtx[$i]=1/(1+exp($tmp_log_odds[$altschul_mapping[$i]]/100));
			    $tmp_log_odds[$i]=1/(1+exp(-$tmp_log_odds[$i]/100)); #altschul_mapping[$i]];
			    #print "$aa_order[$i] $profile_mtx[$i] $profile[$i]\n";
						
			}
 #if (sscanf(buf, "%*d%d%*d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%*d%d", &profile[j][ALA],  &profile[j][CYS], &profile[j][ASP],  &profile[j][GLU],  &profile[j][PHE],  &profile[j][GLY],  &profile[j][HIS],  &profile[j][ILE],  &profile[j][LYS],  &profile[j][LEU],  &profile[j][MET],  &profile[j][ASN],  &profile[j][PRO],  &profile[j][GLN],  &profile[j][ARG],  &profile[j][SER],  &profile[j][THR],  &profile[j][VAL],  &profile[j][TRP],  &profile[j][TYR]) != 20)
			push(@profile_mtx,[@tmp_log_odds]);
		    }
		    
		}
	#	exit;
		close(PROF);

	    }
	    else
	    {
		print "$prof_mtx does not exist cannot read high precision profile...\n";
	    }
	    if(-e $rsa) {
		
		if($rsa=~/\.gz$/) {
		    open(RSA,"gunzip -c $rsa |");
		} else {
		    open(RSA,"$rsa");
		}
		while(<RSA>)
		{
		    if(/^RES/) {
			@temp=split(/\s+/);
#			print $_;
#			print $temp[6]."\n";
			push(@rsa,$temp[6]);
		    }
		}
	#	exit;
		close(RSA);

	    }
	    else #if($param{-rsa})
	    {
		print "$rsa does not exist cannot read surface info...\n";
		next;
	    }
	    if(-e $mprap_file) {
		
		open(RSA,"$mprap_file");
		while(<RSA>)
		{
		    if(/^\w\s\w\s/) {
			@temp=split(/\s+/);
			push(@prsa,$temp[2]);
			push(@shannon,$temp[3]);
		    }
		}
	#	exit;
		close(RSA);

	    }elsif(-e $prsa_file) {
		#print $prsa_file."\n";
#		my $tmp_str=`head -n 2 $prsa_file | tail -n 1`;
		my $tmp_str=`tail -n 1 $prsa_file`; #head -n 2 $prsa_file | tail -n 1`;
		chomp($tmp_str);
		@prsa=split(//,$tmp_str);
		$prsa[0]="e";
		$prsa[$#prsa]="e";
		for(my $i=0;$i<scalar(@prsa);$i++) {

		    $prsa[$i]=20 if($prsa[$i] eq "b");
		    $prsa[$i]=75 if($prsa[$i] eq "e");
		   # print $prsa[$i];
		}
		#print "\n";
		
	    }
	    else #if($param{-rsa})
	    {
		if(!$casp7) {
		    print "$mprap_file or $prsa_file does not exist cannot read surface info...\n";
		    next;
		} 
#else {
#		    "$mprap_file or $prsa_file does not exist cannot read surface info...\n";
#		}
		
	    }
	   # print $prsa_file."\n";
	   # exit;
	    if(-e $co_file) {
		open(CO,"$co_file");
		while(<CO>)
		{
		    if(/^\d+/) {
			@temp=split(/\s+/);
#			print $_;
#			print $temp[6]."\n";
			push(@co,$temp[1]);
			push(@co_count,$temp[2]);
		    }
		}
	#	exit;
		close(CO);
		
	    }
	    elsif($param{-co}) {
		print "$co_file does not exist cannot read co info...\n";
		next;
	    }

	    #check
	  #  $zlen=scalar(@zpred);
	  #  print "$length $zlen\n";
	    if($length == scalar(@Sscore) && $length == scalar(@entropy)) 
	    {
#		$svmout="$outdir/$file.svm.$id2set{$id}.SscoreNorm$Sscore_cutoff";
		if($dir_is_file) {
		    #$prefix="";
		    $statfile="$outdir/$prefix$file_base.mean_Sscore";
		    $svmout2="$outdir/$prefix$file_base.svm";
		    $indexout="$outdir/$prefix$file_base.index";
		    $svmout_proqres_pred="$outdir/$prefix$file_base.svm.ProQres.Pred";
		} elsif($casp7_test) {
		    $svmout2="$outdir/$file.svm.$casp7_setid{$target_id}";
		    $indexout="$outdir/$file.index";
		    $svmout_proqres_pred="$outdir/$file.svm.$casp7_setid{$target_id}.ProQres.Pred";

		}
		elsif($rosetta || $relax) {
		    $statfile="$outdir/$file";
		    $svmout2="$outdir/$file.svm";
		    $indexout="$outdir/$file.index";
		    $svmout_proqres_pred="$outdir/$file.svm.ProQres.Pred";

		}
		else
		{
		    $statfile="$outdir/$file.$id2clust{$id}.mean_Sscore";
		    $svmout2="$outdir/$file.svm.$id2set{$id}";
		    $indexout="$outdir/index";
		    $svmout_proqres_pred="$outdir/$file.svm.$id2set{$id}.ProQres.Pred";
		}
		#open(STAT,">$statfile") || die "Cannot open $statfile\n";
		#print STAT "$mean_Sscore $std_Sscore\n";
		#close(STAT);
		#if(!-e $svmout_proqres_pred) 
		{
		    print $svmout2."\n";
		    #open(OUT, ">$svmout") || die;
		    
		    open(OUT2, ">$svmout2") || die "Cannot open $svmout2 for writing\n";
		    open(OUT3, ">$svmout_proqres_pred") || die "Cannot open $svmout_proqres_pred for writing\n";;
		    open(IN, "gunzip -c $proqoutfile.gz|") || die "Cannot open $proqoutfile.gz for reading\n";;
		    @data=(); #the training data.
		    %hash=(); #fancy hash...
		    while(<IN>) {
			chomp $_;
			next if ($_ eq '');
			if ($_ =~ /^\#/) {
			    next;
			}
			my ($id, @para) = split(/\s+/, $_);
			if($id=~/POS:/) {
			    $position=$para[0];
			}
			$id=~s/://g;
			if($id=~/ATOM|RES|SURF|PROQRES|SS/) {
			    @{$hash{$position}{$id}}=@para; #This fancy thing is a hash of a hash of an array.... hehe, the first key is the position and the second is the id (ATOM,RES, SURF etc....). At the end you will have the whole file in memory easily accessible through the key look up. This is one of the things that makes perl (in my opinion superior to all other scripting languages - it is really easy to read in formatted data into a hash which you then can access rapidly. 
			}
	
			
			if(/^TER/) {
			    #print OUT "$Sscore_norm[$position-1] ";
			    print OUT2 "$Sscore[$position-1] ";
			    print OUT3 "$file $Sscore[$position-1] $hash{$position}{PROQRES}[0]\n";
			    my $i = 0;
			    @data=();
			    $index=1;
			    #build up an array of the data we want to use for training.
			    foreach $key(@training_ids) {
				for(my $i=0;$i<@{$hash{$position}{$key}};$i++) {
				    $p=$i+1;
				    push(@index,"$index $key $p");
				    $index++;
				}

				@data=(@data,@{$hash{$position}{$key}});
				
			    }
			    if($param{-ss_content}) {
				
		#		my $win=$param{-ss_content};
	#			print "Using windowsize $win for ss_content!\n" if($position==1);
				$string="";
				#	print "$position: $ss[$position-1] ";
				my $h=0;
				my $e=0;
				my $c=0;
#				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2 && $i<=scalar(@Sscore);$i++)
				for($i=1;$i<=scalar(@ss);$i++) #$position-($win-1)/2;$i<=$position+($win-1)/2 && $i<=scalar(@Sscore);$i++)
				{
				    if($i<1 || $i> scalar(@ss))
				    {
					next;
#					$h=0;
#					$e=0;
#					$c=0;
				    }
				    else
				    {
					if($ss[$i-1] eq 'H') {
					    $h=$h+1;
					}
					elsif($ss[$i-1] eq 'E') {
					    $e=$e+1;
					}
					elsif($ss[$i-1] eq 'C') {
					    $c=$c+1;
					}
				    }
				}
				#    print "$ss ";
				my $t=$h+$c+$e;
				my $fh=$h/$t;
				my $fe=$e/$t;
				my $fc=$c/$t;
				push(@data,$fh);
				push(@index,"$index ss_content helix");
				$index++;
				push(@data,$fe);
				push(@index,"$index ss_content sheet");
				$index++;
				push(@data,$fc);
				push(@index,"$index ss_content coil");
				$index++;

				
				#print "\n";
			    }
			    if($param{-stride}) {
				my $win=$param{-stride};
				print "Using windowsize $win for stride!\n" if($position==1);
				$string="";
			#	print "$position: $ss[$position-1] ";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    my $h=0;
				    my $e=0;
				    my $c=0;
				    if($i<1 || $i> scalar(@ss))
				    {
					$h=0;
					$e=0;
					$c=0;
				    }
				    else
				    {
					if($ss[$i-1] eq 'H') {
					    $h=1;
					}
					elsif($ss[$i-1] eq 'E') {
					    $e=1;
					}
					elsif($ss[$i-1] eq 'C') {
					    $c=1;
					}
				    }
				    push(@data,$h);
				    push(@index,"$index stride helix $i");
				    $index++;
				    push(@data,$e);
				    push(@index,"$index stride sheet $i");
				    $index++;
				    push(@data,$c);
				    push(@index,"$index stride coil $i");
				    $index++;
				}
				#print "\n";
			    }
			    if($param{-ss}) {
				my $win=$param{-ss};
				print "Using windowsize $win for ss!\n" if($position==1);
				$string="";
			#	print "$position: $ss[$position-1] ";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    my $ss=0;
				    if($i<1 || $i> scalar(@ss))
				    {
					$ss=0;
				    }
				    else
				    {
					if($ss[$i-1] eq 'H') {
					    $ss=$helix[$i-1];
					}
					elsif($ss[$i-1] eq 'E') {
					    $ss=$sheet[$i-1];
					}
					elsif($ss[$i-1] eq 'C') {
					    $ss=$coil[$i-1];
					}
				    }
				#    print "$ss ";
				    push(@data,$ss);
				    push(@index,"$index ss $i");
				    $index++
				}
				#print "\n";
				
			    }
			    if($param{-ss_sc}) {
				my $win=$param{-ss_sc};
				print "Using windowsize $win for ss_sc!\n" if($position==1);
				#$string="";
			#	print "$position: $ss[$position-1] ";
				my $correct=0;
				my $count=0;
				my $prob_sum=0;
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    
				    #my $ss=0;
				    if($i<1 || $i> scalar(@ss))
				    {
					#$ss=0;
				    }
				    else
				    {
#					print "ss $i\n";
					#print "$i: $ss[$i-1] $ss_pred[$i-1] $helix[$i-1] $coil[$i-1] $sheet[$i-1]\n";
					if($ss[$i-1] eq $ss_pred[$i-1]) {
#					    $ss=$helix[$i-1];
					    $correct++;
					    
					}
					#if($ss[$i-1] eq 'H') {
					#    $prob_sum+=$helix[$i-1];
					#}
					#elsif($ss[$i-1] eq 'E') {
					#    $prob_sum+=$sheet[$i-1];
					#}
					#elsif($ss[$i-1] eq 'C') {
					#    $prob_sum+=$coil[$i-1];
					#}

					$count++;
				    }
				}
				#    print "$ss ";
				push(@data,$correct/$count);
				push(@index,"$index ss_sc");
				$index++;
				#print "ss_sc $correct $count\n";
				#push(@data,$prob_sum/$correct);
				#push(@index,"$index ss_prob_sum");
				#$index++
				
				#print "\n";
				
			    }
			    if($param{-gss_sc}) {
				my $correct=0;
				my $count=0;
				my $prob_sum=0;
				for($i=1;$i<=scalar(@ss);$i++)
				{
				    #print "gss $i\n";
				    #my $ss=0;
				    if($i<1 || $i> scalar(@ss))
				    {
					#$ss=0;
				    }
				    else
				    {
					#print "gss $i\n";
					#print "$i: $ss[$i-1] $ss_pred[$i-1] $helix[$i-1] $coil[$i-1] $sheet[$i-1]\n";
					if($ss[$i-1] eq $ss_pred[$i-1]) {
#					    $ss=$helix[$i-1];
					    $correct++;
					    
					}
					#if($ss[$i-1] eq 'H') {
					#    $prob_sum+=$helix[$i-1];
					#}
					#elsif($ss[$i-1] eq 'E') {
					#    $prob_sum+=$sheet[$i-1];
					#}
					#elsif($ss[$i-1] eq 'C') {
					#    $prob_sum+=$coil[$i-1];
					#}

					$count++;
				    }
				}
				#    print "$ss ";
				push(@data,$correct/$count);
				push(@index,"$index gss_sc");
				$index++;
			#	print "gss_sc $correct $count\n";
				#push(@data,$prob_sum/$correct);
				#push(@index,"$index ss_prob_sum");
				#$index++
				
				#print "\n";
				
			    }


			    if($param{-topology}) {
				my $win=$param{-topology};
				print "Using windowsize $win for topology!\n" if($position==1);
				$string="";
			#	print "$position: $ss[$position-1] ";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    $ss=0;
				    if($i<1 || $i> scalar(@topology))
				    {
					$topology=0;
				    }
				    else
				    {
					$topology=0;
					if($topology[$i-1] eq 'M') {
					    $topology=1;
					}
				    }
				#    print "$ss ";
				    push(@data,$topology);
				    push(@index,"$index topology $i");
				    $index++
				}
				#print "\n";
			    }
			    if($param{-zpred}) {
				my $win=$param{-zpred};
				print "Using windowsize $win for zpred!\n" if($position==1);
				$string="";
			#	print "$position: $ss[$position-1] ";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    
				    $zpred=$zpred[0];
				    if($i<1)
				    {
					$zpred=$zpred[0];
				    }
				    elsif($i> scalar(@zpred)){
					$zpred=$zpred[$#zpred];
				    }
				    else
				    {
					$zpred=$zpred[$i-1];
				    }
				#    print "$ss ";
				    $zpred=($zpred-5)/20;
				    push(@data,$zpred);
				    push(@index,"$index zpred (normalized (z-5)/20");
				    $index++
				}
				#print "\n";
			    }
			    if($param{-z}) {
				my $win=$param{-z};
				print "Using windowsize $win for z!\n" if($position==1);
				$string="";
			#	print "$position: $ss[$position-1] ";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    
				    $z=$z[0];
				    if($i<1)
				    {
					$z=$z[0];
				    }
				    elsif($i> scalar(@z)){
					$z=$z[$#z];
				    }
				    else
				    {
					$z=$z[$i-1];
				    }
				#    print "$ss ";
				    $z=($z-5)/20;
				    push(@data,$z);
				    push(@index,"$index z (normalized (z-5)/20");
				    $index++
				}
				#print "\n";
			    }
			     if($param{-z_sc}) {
				my $win=$param{-z_sc};
				print "Using windowsize $win for z_sc!\n" if($position==1);
				$string="";
			#	print "$position: $ss[$position-1] ";
				#$count=0;
				#$correct=0;
				$error=0;
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    
				    if($i<1)
				    {
					$z=$z[0];
					$zpred=$zpred[0];
				    }
				    elsif($i> scalar(@z)){
					$z=$z[$#z];
					$zpred=$zpred[$#zpred];
				    }
				    else
				    {					
					$z=$z[$i-1];
					$zpred=$zpred[$i-1];
				    }
				    $z=($z-5)/20;
				    $zpred=($zpred-5)/20;
				    $error+=abs($z-$zpred);
				}
				#    print "$ss ";
				push(@data,$error);
				push(@index,"$index z_sc");
				$index++
				#print "\n";
			    }
			    

			    if($param{-co}) {
				my $win=$param{-co};
				print "Using windowsize $win for contact order!\n" if($position==1);
				my $co=0;
				my $co_count=0;
				my $order=0;
				#	print "$position: $ss[$position-1] ";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    if($i<1 || $i> scalar(@co))
				    {
					#void
				    }
				    else
				    {
					$co+=$co[$i-1];
					$co_count+=$co_count[$i-1];
					
				    }
				#    print "$ss ";
#				    push(@data,$topology);
				}
				if($co_count!=0) {
				    $order=$co/$co_count/$length;
				}
				push(@data,$order);
				push(@index,"$index co $i");
				$index++
				#print "\n";
			    }

			    if($param{-entropy}){
				
				$win=$param{-entropy};
				print "Using windowsize $win for the entropy!\n" if($position==1);
				$string="";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    if($i<1 || $i> scalar(@entropy))
				    {
					$entropy=0;
				    }
				    else
				    {
					$entropy=$entropy[$i-1];
				    }
				    push(@data,$entropy);
				    push(@index,"$index entropy $i");
				    $index++;
				    #$string.="$entropy ";
				}
				#print $string."\n";

			    }
			    if($param{-shannon}){
				
				$win=$param{-shannon};
				print "Using windowsize $win for the shannon!\n" if($position==1);
				$string="";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    if($i<1 || $i> scalar(@shannon))
				    {
					$shannon=0;
				    }
				    else
				    {
					$shannon=$shannon[$i-1];
				    }
				    push(@data,$shannon);
				    push(@index,"$index shannon $i");
				    $index++;
				    #$string.="$entropy ";
				}
				#print $string."\n";

			    }
			    if($param{-profile}){

				$win=$param{-profile};
				print "Using windowsize $win for the profile!\n" if($position==1);
				$string="";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    @log_odds=();
				    if($i<1 || $i> scalar(@profile_mtx))
				    {
					for(my $j=0;$j<20;$j++) {
					    push(@log_odds,0);
					}
				    }
				    else
				    {
					@log_odds=@{$profile_mtx[$i-1]};
				    }
				    push(@data,@log_odds);
				    foreach (@log_odds) {
					push(@index,"$index profile $i");
					$index++;
				    }
				    #$string.="$entropy ";
				}
				#print $string."\n";

			    }
			    if($param{-rsa})
			    {

				my $win=$param{-rsa};
				print "Using windowsize $win for the rsa!\n" if($position==1);
				$string="";
				#print "$position: ";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    my $area=0;
				    if($i<1 || $i> scalar(@rsa))
				    {
					$area=0;
				    }
				    else
				    {
					$area=$rsa[$i-1]/100;
				    }
				    push(@data,$area);
				    push(@index,"$index rsa $i");
				    $index++
				 #   print "$area ";
				    #$string.="$entropy ";
				}
				#print "\n";
				#print $string."\n";

			    }
			    if($param{-prsa})
			    {

				my $win=$param{-prsa};
				print "Using windowsize $win for the -prsa!\n" if($position==1);
				$string="";
				#print "$position: ";
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    my $area=0;
				    if($i<1 || $i> scalar(@prsa))
				    {
					$area=0;
				    }
				    else
				    {
					$area=$prsa[$i-1]/100;
				    }
				    push(@data,$area);
				    push(@index,"$index prsa $i");
				    $index++
				 #   print "$area ";
				    #$string.="$entropy ";
				}
				#print "\n";
				#print $string."\n";

			    }
			    if($param{-rsa_sc})
			    {

				my $win=$param{-rsa_sc};
				print "Using windowsize $win for the -rsa_sc!\n" if($position==1);
				
				$string="";
				#print "$position: ";
				my $pred_agree=0;
				my $count=0;
				for($i=$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    
				    
				    if($i<1 || $i> scalar(@prsa))
				    {
					#$area=0;
				    }
				    else
				    {
					
					if($prsa[$i-1] < 25 && 
					   $rsa[$i-1] < 25 ||
					   $prsa[$i-1] > 25 &&
					   $rsa[$i-1] > 25) {
					    $pred_agree++;
					}
					$count++;
				    }
				}
				push(@data,$pred_agree/$count); #area);
				push(@index,"$index rsa_sc");
				$index++
				 #   print "$area ";
				    #$string.="$entropy ";
			
				#print "\n";
				#print $string."\n";

			    }
			    if($param{-grsa_sc})
			    {

							
				$string="";
				#print "$position: ";
				my $pred_agree=0;
				my $count=0;
				for($i=1;$i<=scalar(@prsa);$i++) #$position-($win-1)/2;$i<=$position+($win-1)/2;$i++)
				{
				    
				    
				    if($i<1 || $i> scalar(@prsa))
				    {
					#$area=0;
				    }
				    else
				    {
					
					if($prsa[$i-1] < 25 && 
					   $rsa[$i-1] < 25 ||
					   $prsa[$i-1] > 25 &&
					   $rsa[$i-1] > 25) {
					    $pred_agree++;
					}
					$count++;
				    }
				}
				push(@data,$pred_agree/$count); #area);
				push(@index,"$index grsa_sc");
				$index++
				 #   print "$area ";
				    #$string.="$entropy ";
			
				#print "\n";
				#print $string."\n";

			    }
			    if($param{-termini})
			    {
				my $distN=$position-1;
				my $distC=$length-$position;
				

				my $distN_norm=$distN/$param{-termini};
				my $distC_norm=$distC/$param{-termini};
				$distN_norm=1 if($distN_norm>1);
				$distC_norm=1 if($distC_norm>1);
				
				#print "$position $distN_norm $distC_norm\n";
				push(@data,$distN_norm);
				push(@index,"$index terminiN");
				$index++;
				push(@data,$distC_norm);
				push(@index,"$index terminiC");
				$index++;
			    }
			    #if($param{-termini2})
			    #{
			    #	my $distN=$position-1;
			    #	my $boolN=0;
			    #	my $boolC=0;
			    #	my $distC=$length-$position;
			    #	
			    #	if($distN<=$param{-termini2}) {
			    #	    $boolN=1;
			    #	}
			    #	if($distC<=$param{-termini2}) {
			    #	    $boolC=1;
			    #	}
			    #	push(@data,$boolN);
			    #	push(@data,$boolC);
			    #}

			    for ($i = 0; $i < @data; $i++) {
				my $feature = $i+1;
				my $value = $data[$i];
				@test=split(/\s+/,$feature);
				if(scalar(@test)!=1) {
				    print "ERROR ERROR$file feature data missmatch\n";
				    exit(1);
				}
				#print OUT "$feature:$value ";
				print OUT2 "$feature:$value ";
			    }
			   # print OUT "\n";
			    print OUT2 "\n";
			    @data=();
			    if($position==1 && !-e $indexout) {
				open(INDEX,">$indexout") || die;
				for ($i = 0; $i < @index; $i++) {
				    print INDEX "$index[$i]\n";
				}
				close(INDEX);
			    }
			    @index=();
			    
			}
		    }
		    close(IN);
		    #close(OUT);
		    close(OUT2);
		    close(OUT3);
		#    exit;

		    
		}
		if($rosetta || $relax) {
		    print "Gzipping..\n";
#		    `gzip -f $statfile`;
		    `gzip -f $svmout2`;
		    `gzip -f $indexout`;
		    `gzip -f $svmout_proqres_pred`;
		    `gzip -f $stride`;
		    `gzip -f $rsa`;
		}
	    }
	    else
	    {
		$len1=scalar(@Sscore);
		print "inconsistancy in the number of residues in the $proqoutfile ($length) and $Sscorefile ($len1)... Skipping\n";
		if($length == 0 )
		{
		    `rm -f $proqoutfile.gz`;
#		`cat $proqoutfile`;
		}
	    
	    }
	    #exit;
	}

}
#import os,commands,sys

#arg = sys.argv

#print arg

#if not(len(arg) == 3):
#	print "Usage" + arg[0] + " [input directory] [output directory]"
#	sys.exit(128)
#else: 
#	for r, d, f in os.walk(arg[1]):
#		for file in f:
#
#			if (file.split('.')[-1] == "pdb") or (file.split('.')[-1] == "fixed"):
#				o = commands.getoutput("/afs/pdc.kth.se/home/b/bjornw/source/c/pdb/ProQres/PROQRES/bin/ProQres64 -pdb " + r + "/" + file + " -output_atom")
#
#				output = open(arg[2] + "/" + file + ".proq", "w")
#				output.write(o)
#				output.close()





sub read_in_psipred2
{
    my $file=shift;
    #my $target_seq=shift;
    my $seq="";
    my $ss_pred="";
    my @helix=();
    my @sheet=();
    my @coil=();
    my @psipred=();
    open(FILE,"$file"); # or die "Cannot open $file.\n";
    while(<FILE>)
    {
	if(/\d+\s+(\w)\s+([HCE])\s+([\d\.\-]+)\s+([\d\.\-]+)\s+([\d\.\-]+)/)
	{
	    #print;
	    chomp;
	    #@temp=split(/\s+/);
	    #push(@coil,$temp[4]);
	    #push(@helix,$temp[5]);
	    #push(@sheet,$temp[6]);
	    #$ss_pred.=$temp[3];
	    #$seq.=$temp[2];

#	    @temp=split(/\s+/);
	    push(@coil,$3);
	    push(@helix,$4);
	    push(@sheet,$5);
	    $ss_pred.=$2;
	    $seq.=$1;
	}
    }
    close(FILE);
    #while(<FILE>)
    #{
    #	if(/\s+\d+/)
    #	{
    #	    chomp;
    #	    @temp=split(/\s+/);
    #	    push(@coil,$temp[4]);
    #	    push(@helix,$temp[5]);
    #	    push(@sheet,$temp[6]);
    #	    $ss_pred.=$temp[3];
    #	    $seq.=$temp[2];
    #	}
    #}
    #close(FILE);
    #print "$seq\n$ss_pred\n";
    #exit;
    #generate_top_code($ss_pred,10,110);
    return ($seq,$ss_pred,[@helix],[@sheet],[@coil]);

}
sub read_in_stride
{
    my $file=shift;
    my $seq="";
    my $ss="";
    if($file=~/\.gz$/) {
	open(FILE,"gunzip -c $file |");
    } else {
	open(FILE,"$file");
    }
    #open(FILE,"$file") || die "Cannot open $file. (bjornlib)\n";
    while(<FILE>)
    {
	chomp;
	if(/^SEQ/)
	{
	    #print substr($_,10,50)."\n";
	    $seq.=substr($_,10,50);
	}
	if(/^STR/)
	{
	    #print substr($_,10,50)."\n";
	    $ss.=substr($_,10,50);
	}
	last if(/^LOC/);
    }
    #Remove white spaces at end.
    $seq=~s/ //g;
    $ss=substr($ss,0,length($seq));
    my @temp=split(//,$ss);
    my $return_ss="";
    foreach my $ss_a(@temp)
    {
	#print $ss_a."\n";
	if($ss_a eq 'H' || $ss_a eq 'G' || $ss_a eq 'I')
	{
	    $return_ss.="H";
	}
	elsif($ss_a eq "E")
	{
	    $return_ss.="E";
	}
	else
	{
	    $return_ss.="C";
	}
    }
    #print "$seq\n$return_ss\n$ss\n";
    return($seq,$return_ss);
}

#!/usr/bin/perl -w


sub parse_topcons
{
    my $file=shift;
    my $topcons="";
    my $seq="";
    my $octopus="";
    my $get_data=0;
    open(FILE,$file);
    while(<FILE>)
    {
	if($get_data) {
	    chomp;
	    if(/^\s+TOPCONS\s+([iMo\s]+)/)
	    {
		#    print;
		#    print "\n";
		$topcons.=$1;
		
	    }
	    if(/^\s+OCTOPUS\s+([iMo\s]+)/)
	    {
		#    print;
		#    print "\n";
		$octopus.=$1;
		
	    }
	    if(/^\s+Seq\.\s+([A-Z\s]+)/) {
		
		#   print;
		#   print "\n";
		$seq.=$1;
	    }
	}
	$get_data=1 if(/Sequence and predicted topologies:/);
	
    }
    $seq=~s/\s+//g;
    $topcons=~s/\s+//g;
    $octopus=~s/\s+//g;
    $topcons=$octopus if(length($topcons)==0);
   # print "FILE $file\n";
    #print "SEQ     $seq\n";
    #print "TOPCONS $topcons\n";
    close(FILE);
    return($seq,$topcons);
}


#sub parse_topcons
#{
#    my $file=shift;
#    my $topcons="";
#    my $seq="";
#    my $octopus="";
#    open(FILE,$file);
#    while(<FILE>)
#    {
#	chomp;
#	if(/^\s+TOPCONS\s+([iMo\s]+)/)
#	{
#	#    print;
#	#    print "\n";
#	    $topcons.=$1;
#	    
#	}
#	if(/^\s+OCTOPUS\s+([iMo\s]+)/)
#	{
#	#    print;
#	#    print "\n";
#	    $octopus.=$1;
#	    
#	}
#	if(/^\s+Seq\.\s+([A-Z\s]+)/) {
#	    
#	 #   print;
#	 #   print "\n";
#	    $seq.=$1;
#	}
#	
#    }
#    $seq=~s/\s+//g;
#    $topcons=~s/\s+//g;
#    $octopus=~s/\s+//g;
#    $topcons=$octopus if(length($topcons)==0);
#   # print "FILE $file\n";
#    #print "SEQ     $seq\n";
#    #print "TOPCONS $topcons\n";
#    close(FILE);
#    return($seq,$topcons);
#}

sub parse_Zpred
{
     my $file=shift;
     my @zpred=();
     

     open(Z,"$file");
     while(<Z>) {
	 my @temp=split(/\s+/);
	 push(@zpred,$temp[0]);

     }
     return(@zpred);

}
sub parse_Z
{
     my $file=shift;
     my @z=();
     
     if($file=~/\.gz$/) {
	open(FILE,"gunzip -c $file |");
    } else {
	open(FILE,"$file");
    }
     while(<FILE>) {
	 my @temp=split(/\s+/);
	 $z=$temp[2];
	 $z=25 if($z>25);
	 $z=5 if($z<5);
	 push(@z,$z);

     }
     return(@z);
     close(FILE);
}




sub usage
{
    print "\n\tScript for generating SVM input takes a number of arguments and generate output accordingly:\n";
    print "\t The arguments comes in two flavours\n";
    print "\t1) -Something <win size> which turns something on if its !=0 and also sets the window size\n";
    print "\t2) -Something <0/1> which turns something off/on\n";
    print "\tIt is important that all -Something is followed by a value even if it is 0\n";
    print "\n\tArguments:\n";
    print "\t-i <input folder, membrane/wallner_set etc>\n";
    print "\t-o <output folder, a subfolder will be created in this folder with a uniq name>\n";
    print "\t-Sscore <cutoff, default: 5>\n";
    print "\t-atom <use atom contacts, 0/1>\n";
    print "\t-entropy <use entropy, win size, 0=no entropy>\n";
    print "\t-profile <use profile (logistic transformation on the log-odds matrix, like psipred does), win size, 0=no profile>\n";
    print "\t-pw <use profile_weight for the residue contacts and surfaces 0/1>\n";
    print "\t-res <use residue-residue contacts, 0/1>\n";
    print "\t-rsa 0 <use relative surface accessible area i.e the exact area, win size, 0=no rsa>\n";
    print "\t-ss <use predicted secondary structure information, win size, 0=no ss info>\n";
    print "\t-surf100 <use fraction of residues(types) > 100% relative exposure, 0/1>\n";
    print "\t-surf25 <use fraction of residues(types) < 25% relative exposure, 0/1>\n";
    print "\t-surf50 <use fraction of residues(types) 25%-50% relative exposure, 0/1>\n";
    print "\t-surf75 <use fraction of residues(types) 50%-75% relative exposure, 0/1>\n";
    print "\t-topology <use topology information, win size, 0=no topology, only for membranes obviously>\n";
    print "\t-stride <secondary structure from the model, win size>\n";
    print "\t-n <maximum number of representative from a given sequence cluster, default=10>\n";
    print "\t-termini X <min(X/{-termini},1), X=distance to termini>\n";
   # print "\t-termini2 X <is wihtin X residue from termini, default X=0>\n";
    print "\t-restypes <residuetypes to use for res-res contacts 6,20,623,622,632, default=6>\n";
    print "\t-pwin <windowsize for local contacts/surf, default=9>\n";
    print "\t-rc <res-res contact cutoff default=5>\n";
    print "\t-ac <atom-atom contact cutoff default=5>\n";
    print "\t-ss_content <secondary structure content over a window default=0>\n";
    


}
